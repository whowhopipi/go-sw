// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Lowering arithmetic
(Add(Ptr|64|32|16|8) ...) => (ADDV ...)
(Add(32|64)F ...) => (FADD(S|D) ...)

(Sub(Ptr|64|32|16|8) ...) => (SUBV ...)
(Sub(32|64)F ...) => (FSUB(S|D) ...)

// (x + y) / 2 with x>=y => (x - y) / 2 + y
(Avg64u <t> x y) => (ADDV (SRLconst <t> (SUBV <t> x y) [1]) y)

(Mul(64|32|16|8) ...) => (MUL(L|W|W|W) ...)
(Mul(32|64)F ...) => (FMUL(S|D) ...)

(Hmul64  x y) => ( SUBV <typ.Int64> (SUBV <typ.Int64> (UMULH  <typ.Int64> x y) (MULL <typ.Int64> (SRLconst x [63]) y)) (MULL <typ.Int64> (SRLconst y [63]) x) )
(Hmul64u  ...) => (UMULH  ...)
(Hmul32 x y) => (SRAconst (MULL <typ.Int64> (SignExt32to64 x) (SignExt32to64 y)) [32])
(Hmul32u x y) => (SRLconst (MULL <typ.UInt64> (ZeroExt32to64 x) (ZeroExt32to64 y)) [32])


(Convert ...) => (MOVVconvert ...)
(GetClosurePtr ...) => (LoweredGetClosurePtr ...)
(GetCallerSP ...) => (LoweredGetCallerSP ...)
(GetCallerPC ...) => (LoweredGetCallerPC ...)
// Write barrier.
(WB ...) => (LoweredWB ...)

(Signmask x) => (SRAconst x [63])
(Div64 x y) =>
        (SUBV (XOR <typ.UInt64>                                                        // negate the result if one operand is negative
                (Select0 <typ.UInt64> (CALLudiv
                        (SUBV <typ.UInt64> (XOR x <typ.UInt64> (Signmask x)) (Signmask x))   // negate x if negative
                        (SUBV <typ.UInt64> (XOR y <typ.UInt64> (Signmask y)) (Signmask y)))) // negate y if negative
                (Signmask (XOR <typ.UInt64> x y))) (Signmask (XOR <typ.UInt64> x y)))
(Div64u x y) => (Select0 <typ.UInt64> (CALLudiv x y))
(Div32 x y) => (Div64 (SignExt32to64 x) (SignExt32to64 y))
(Div32u x y) => (Div64u (ZeroExt32to64 x) (ZeroExt32to64 y))
(Div16 x y) => (Div64 (SignExt16to64 x) (SignExt16to64 y))
(Div16u x y) => (Div64u (ZeroExt16to64 x) (ZeroExt16to64 y))
(Div8 x y) => (Div64 (SignExt8to64 x) (SignExt8to64 y))
(Div8u x y) => (Div64u (ZeroExt8to64 x) (ZeroExt8to64 y))
(Div(32|64)F ...) => (FDIV(S|D) ...)


(Mod64 x y) =>
        (SUBV (XOR <typ.UInt64>                                                        // negate the result if x is negative
                (Select1 <typ.UInt64> (CALLudiv
                        (SUBV <typ.UInt64> (XOR <typ.UInt64> x (Signmask x)) (Signmask x))   // negate x if negative
                        (SUBV <typ.UInt64> (XOR <typ.UInt64> y (Signmask y)) (Signmask y)))) // negate y if negative
                (Signmask x)) (Signmask x))
(Mod64u x y) => (Select1 <typ.UInt64> (CALLudiv x y))
(Mod32 x y) => (Mod64 (SignExt32to64 x) (SignExt32to64 y))
(Mod32u x y) => (Mod64u (ZeroExt32to64 x) (ZeroExt32to64 y))
(Mod16 x y) => (Mod64 (SignExt16to64 x) (SignExt16to64 y))
(Mod16u x y) => (Mod64u (ZeroExt16to64 x) (ZeroExt16to64 y))
(Mod8 x y) => (Mod64 (SignExt8to64 x) (SignExt8to64 y))
(Mod8u x y) => (Mod64u (ZeroExt8to64 x) (ZeroExt8to64 y))


// Lowering float <=> int
(Cvt32to32F x) => (FCVTLS (IFMOVD x))
(Cvt32to64F x) => (FCVTLD (IFMOVD (SignExt32to64 x)))
(Cvt64to32F ...) => (FCVTLS ...)
(Cvt64to64F ...) => (FCVTLD ...)
(Cvt32Fto32 x) => (FCVTLW (FCVTDL_Z (FCVTSD x)))
(Cvt64Fto32 x) => (FCVTLW (FCVTDL_Z x))
(Cvt32Fto64 x) => (FCVTDL_Z (FCVTSD x))
(Cvt64Fto64 x) => (FIMOVD (FCVTDL_Z x))
(Cvt32Fto64F ...) => (FCVTSD ...)
(Cvt64Fto32F ...) => (FCVTDS ...)

(Round(32|64)F ...) => (Copy ...)

// count trailing zero
// 64 - CLZ(x&-x - 1)
(Ctz64 ...) => (CTTZ ...)
(Ctz32 <t> x) => (SUBV (CTTZ (ZeroExt32to64 x)) (MULLconst <t> (CMPEQ  (ZeroExt32to64 x)  (MOVVconst [0]) ) [32]))

//count bits
(PopCount64 ...) => (CTPOP ...)
(PopCount32 x) => (CTPOP (ZeroExt32to64 x))
(PopCount16 x) => (CTPOP (ZeroExt16to64 x))
(PopCount8 x) => (CTPOP (ZeroExt8to64 x))

(Floor ...) => (FCVTDL_N ...)
(Ceil ...) => (FCVTDL_P ...)
(Trunc ...) => (FCVTDL_Z ...)
(Round ...) => (FCVTDL_G ...)
(Abs ...) => (FABS ...)
(Copysign x y) => (FCPYS y x)
(Sqrt ...) => (FSQRTD ...)

// Lowering constants
(Const(64|32|16|8) [val]) => (MOVVconst [int64(val)])
(Const(32|64)F [val]) => (MOV(F|D)const [int64(val)])
(ConstNil) => (MOVVconst [0])
(ConstBool [b]) => (MOVVconst [b])

(Slicemask <t> x) => (SRAconst (NEGV <t> x) [63])

// Lowering boolean ops
(AndB ...) => (AND ...)
(OrB ...) => (BIS ...)
(EqB x y) => (XOR (MOVVconst [1]) (XOR <typ.Bool> x y) )
(NeqB ...) => (XOR ...)
(Not x) => (XORconst x [1])

(And(64|32|16|8) ...) => (AND ...)

(Or(64|32|16|8) ...) => (BIS ...)

(Xor(64|32|16|8) ...) => (XOR ...)

// unary ops
(Neg(64|32|16|8) ...) => (NEGV ...)
(Neg(32|64)F ...) => (NEG(F|D) ...)

(Com(64|32|16|8)  x) => (ORNOT (MOVVconst [0]) x)


// shifts
// hardware instruction uses only the low 6 bits of the shift
// we compare to 64 to ensure Go semantics for large shifts
//shifts constant
(Lsh64x64  x (Const64 [c])) && uint64(c) < 64 => (SLLconst x [c])
(Rsh64x64  x (Const64 [c])) && uint64(c) < 64 => (SRAconst x [c])
(Rsh64Ux64 x (Const64 [c])) && uint64(c) < 64 => (SRLconst x [c])
(Lsh32x64  x (Const64 [c])) && uint64(c) < 32 => (SLLconst (ZeroExt32to64 x) [c])
(Rsh32x64  x (Const64 [c])) && uint64(c) < 32 => (SRAconst (SignExt32to64 x) [c])
(Rsh32Ux64 x (Const64 [c])) && uint64(c) < 32 => (SRLconst (ZeroExt32to64 x) [c])
(Lsh16x64  x (Const64 [c])) && uint64(c) < 16 => (SLLconst (ZeroExt16to64 x) [c])
(Rsh16x64  x (Const64 [c])) && uint64(c) < 16 => (SRAconst (SignExt16to64 x) [c])
(Rsh16Ux64 x (Const64 [c])) && uint64(c) < 16 => (SRLconst (ZeroExt16to64 x) [c])
(Lsh8x64   x (Const64 [c])) && uint64(c) < 8  => (SLLconst (ZeroExt8to64 x) [c])
(Rsh8x64   x (Const64 [c])) && uint64(c) < 8  => (SRAconst (SignExt8to64  x) [c])
(Rsh8Ux64  x (Const64 [c])) && uint64(c) < 8  => (SRLconst (ZeroExt8to64  x) [c])

// large constant signed right shift, we leave the sign bit
(Rsh64x64 x (Const64 [c])) && uint64(c) >= 64 => (SRAconst x [63])
(Rsh32x64 x (Const64 [c])) && uint64(c) >= 32 => (SRAconst (SignExt32to64 x) [63])
(Rsh16x64 x (Const64 [c])) && uint64(c) >= 16 => (SRAconst (SignExt16to64 x) [63])
(Rsh8x64  x (Const64 [c])) && uint64(c) >= 8  => (SRAconst (SignExt8to64  x) [63])

// constant shifts
(Rsh64x64 x (MOVVconst [c])) && uint64(c) >= 64 => (SRAconst x [63])
(Rsh32x64 x (MOVVconst [c])) && uint64(c) >= 32 => (SRAconst (SignExt32to64 x) [63])
(Rsh16x64 x (MOVVconst [c])) && uint64(c) >= 16 => (SRAconst (SignExt16to64 x) [63])
(Rsh8x64  x (MOVVconst [c])) && uint64(c) >= 8  => (SRAconst (SignExt8to64  x) [63])

(Lsh64x64  x (MOVVconst [c])) && uint64(c) < 64 => (SLLconst x [c])
(Rsh64x64  x (MOVVconst [c])) && uint64(c) < 64 => (SRAconst x [c])
(Rsh64Ux64 x (MOVVconst [c])) && uint64(c) < 64 => (SRLconst x [c])
(Lsh32x64  x (MOVVconst [c])) && uint64(c) < 32 => (SLLconst (ZeroExt32to64 x) [c])
(Rsh32x64  x (MOVVconst [c])) && uint64(c) < 32 => (SRAconst (SignExt32to64 x) [c])
(Rsh32Ux64 x (MOVVconst [c])) && uint64(c) < 32 => (SRLconst (ZeroExt32to64 x) [c])
(Lsh16x64  x (MOVVconst [c])) && uint64(c) < 16 => (SLLconst (ZeroExt16to64 x) [c])
(Rsh16x64  x (MOVVconst [c])) && uint64(c) < 16 => (SRAconst (SignExt16to64 x) [c])
(Rsh16Ux64 x (MOVVconst [c])) && uint64(c) < 16 => (SRLconst (ZeroExt16to64 x) [c])
(Lsh8x64   x (MOVVconst [c])) && uint64(c) < 8  => (SLLconst (ZeroExt8to64  x) [c])
(Rsh8x64   x (MOVVconst [c])) && uint64(c) < 8  => (SRAconst (SignExt8to64  x) [c])
(Rsh8Ux64  x (MOVVconst [c])) && uint64(c) < 8  => (SRLconst (ZeroExt8to64  x) [c])


(Lsh64x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
(Lsh64x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
(Lsh64x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
(Lsh64x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))

(Lsh32x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
(Lsh32x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
(Lsh32x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
(Lsh32x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))

(Lsh16x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
(Lsh16x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
(Lsh16x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
(Lsh16x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))

(Lsh8x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
(Lsh8x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
(Lsh8x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
(Lsh8x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))

(Rsh64Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> x y))
(Rsh64Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt32to64 y)))
(Rsh64Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt16to64 y)))
(Rsh64Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt8to64  y)))

(Rsh32Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) y))
(Rsh32Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt32to64 y)))
(Rsh32Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt16to64 y)))
(Rsh32Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt8to64  y)))

(Rsh16Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) y))
(Rsh16Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt32to64 y)))
(Rsh16Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt16to64 y)))
(Rsh16Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt8to64  y)))

(Rsh8Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) y))
(Rsh8Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt32to64 y)))
(Rsh8Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt16to64 y)))
(Rsh8Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt8to64  y)))

(Rsh64x64 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
(Rsh64x32 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
(Rsh64x16 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
(Rsh64x8  <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))

(Rsh32x64 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
(Rsh32x32 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
(Rsh32x16 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
(Rsh32x8  <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))


(Rsh16x64 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
(Rsh16x32 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
(Rsh16x16 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
(Rsh16x8  <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))

(Rsh8x64 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
(Rsh8x32 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
(Rsh8x16 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
(Rsh8x8  <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))



// truncations
// Because we ignore high parts of registers, truncates are just copies.
(Trunc16to8 ...) => (Copy ...)
(Trunc32to8 ...) => (Copy ...)
(Trunc32to16 ...) => (Copy ...)
(Trunc64to8 ...) => (Copy ...)
(Trunc64to16 ...) => (Copy ...)
(Trunc64to32 ...) => (Copy ...)

// Zero-/Sign-extensions
(ZeroExt8to16 x) => (ANDconst x [255])
(ZeroExt8to32 x) => (ANDconst x [255])
(ZeroExt16to32 x) => (ANDconst x [65535])
(ZeroExt8to64 x) => (ANDconst x [255])
(ZeroExt16to64 x) => (ANDconst x [65535])
(ZeroExt32to64 x) => (ANDconst x [0xffffffff])

(SignExt8to16 ...) => (SEXTB ...)
(SignExt8to32 ...) => (SEXTB ...)
(SignExt16to32 ...) => (SEXTH ...)
(SignExt8to64 ...) => (SEXTB ...)
(SignExt16to64 ...) => (SEXTH ...)
(SignExt32to64 x) => (ADDWconst x [0])

// Lowering comparisons
//(Greater8U x y)  => (CMPULT (ZeroExt8to64 y) (ZeroExt8to64 x))
//(Greater16U x y) => (CMPULT (ZeroExt16to64 y) (ZeroExt16to64 x))
//(Greater32U x y) => (CMPULT (ZeroExt32to64 y) (ZeroExt32to64 x))
//(Greater64U x y) => (CMPULT y x)
//
//(Greater8 x y)  => (CMPLT (SignExt8to64 y) (SignExt8to64 x))
//(Greater16 x y) => (CMPLT (SignExt16to64 y) (SignExt16to64 x))
//(Greater32 x y) => (CMPLT (SignExt32to64 y) (SignExt32to64 x))
//(Greater64 x y) => (CMPLT y x)
//(Greater(32|64)F x y) => (FEqual  (FCMPLT y x))
//
//(Geq8 x y)  => (CMPLE (SignExt8to64 y) (SignExt8to64 x))
//(Geq16 x y) => (CMPLE (SignExt16to64 y) (SignExt16to64 x))
//(Geq32 x y) => (CMPLE (SignExt32to64 y) (SignExt32to64 x))
//(Geq64 x y) => (CMPLE  y x)
//(Geq(32|64)F x y) => (FEqual (FCMPLE y x))
//
//(Geq8U x y)  => (CMPULE (ZeroExt8to64 y) (ZeroExt8to64 x))
//(Geq16U x y) => (CMPULE (ZeroExt16to64 y) (ZeroExt16to64 x))
//(Geq32U x y) => (CMPULE (ZeroExt32to64 y) (ZeroExt32to64 x))
//(Geq64U x y) => (CMPULE y x)


(Eq8 x y)  => (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y))
(Eq16 x y) => (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y))
(Eq32 x y) => (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y))
(Eq64 ...) => (CMPEQ ...)
(EqPtr ...) => (CMPEQ ...)
(Eq(32|64)F x y) => (FEqual (FCMPEQ x y))

(Neq8 x y)  => (Not (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y)))
(Neq16 x y) => (Not (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y)))
(Neq32 x y) => (Not (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y)))
(Neq64 x y) => (Not (CMPEQ x y))
(NeqPtr x y) => (Not (CMPEQ x y))
(Neq(32|64)F x y) => (FNotEqual (FCMPEQ x y))

(Less8 x y)  => (CMPLT (SignExt8to64 x) (SignExt8to64 y))
(Less16 x y) => (CMPLT (SignExt16to64 x) (SignExt16to64 y))
(Less32 x y) => (CMPLT (SignExt32to64 x) (SignExt32to64 y))
(Less64 ...) => (CMPLT ...)
(Less(32|64)F x y) => (FEqual (FCMPLT x y))

(Less8U x y)  => (CMPULT (ZeroExt8to64 x) (ZeroExt8to64 y))
(Less16U x y) => (CMPULT (ZeroExt16to64 x) (ZeroExt16to64 y))
(Less32U x y) => (CMPULT (ZeroExt32to64 x) (ZeroExt32to64 y))
(Less64U ...) => (CMPULT ...)

(Leq8 x y)  =>  (CMPLE (SignExt8to64 x) (SignExt8to64 y))
(Leq16 x y) => (CMPLE (SignExt16to64 x) (SignExt16to64 y))
(Leq32 x y) =>  (CMPLE (SignExt32to64 x) (SignExt32to64 y))
(Leq64 ...) =>  (CMPLE ...)
(Leq(32|64)F x y) => (FEqual (FCMPLE x y))

(Leq8U x y)  => (CMPULE (ZeroExt8to64 x) (ZeroExt8to64 y))
(Leq16U x y) => (CMPULE (ZeroExt16to64 x) (ZeroExt16to64 y))
(Leq32U x y) => (CMPULE (ZeroExt32to64 x) (ZeroExt32to64 y))
(Leq64U ...) => (CMPULE ...)


(OffPtr [off] ptr:(SP)) => (SYMADDR [off] ptr)
(OffPtr [off] ptr) => (ADDVconst [off] ptr)
(Addr {sym} base) => (SYMADDR {sym} base)
(LocalAddr {sym} base _) => (SYMADDR {sym} base)

// loads
(Load <t> ptr mem) && t.IsBoolean() => (MOVBUload ptr mem)
(Load <t> ptr mem) && (is8BitInt(t) && isSigned(t)) => (MOVBload ptr mem)
(Load <t> ptr mem) && (is8BitInt(t) && !isSigned(t)) => (MOVBUload ptr mem)
(Load <t> ptr mem) && (is16BitInt(t) && isSigned(t)) => (MOVHload ptr mem)
(Load <t> ptr mem) && (is16BitInt(t) && !isSigned(t)) => (MOVHUload ptr mem)
(Load <t> ptr mem) && (is32BitInt(t) && isSigned(t)) => (MOVWload ptr mem)
(Load <t> ptr mem) && (is32BitInt(t) && !isSigned(t)) => (MOVWUload ptr mem)
(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) => (MOVVload ptr mem)
(Load <t> ptr mem) && is32BitFloat(t) => (MOVFload ptr mem)
(Load <t> ptr mem) && is64BitFloat(t) => (MOVDload ptr mem)

// fold address into load/store
(MOVBload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVBload  [off1+off2] {sym} ptr mem)
(MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVBUload [off1+off2] {sym} ptr mem)
(MOVHload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVHload  [off1+off2] {sym} ptr mem)
(MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVHUload [off1+off2] {sym} ptr mem)
(MOVWload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVWload  [off1+off2] {sym} ptr mem)
(MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVWUload [off1+off2] {sym} ptr mem)
(MOVVload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVVload  [off1+off2] {sym} ptr mem)
(MOVFload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVFload  [off1+off2] {sym} ptr mem)
(MOVDload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVDload  [off1+off2] {sym} ptr mem)

(MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVBstore [off1+off2] {sym} ptr val mem)
(MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVHstore [off1+off2] {sym} ptr val mem)
(MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVWstore [off1+off2] {sym} ptr val mem)
(MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVVstore [off1+off2] {sym} ptr val mem)
(MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVFstore [off1+off2] {sym} ptr val mem)
(MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(off1+off2) => (MOVDstore [off1+off2] {sym} ptr val mem)
(MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVBstorezero [off1+off2] {sym} ptr mem)
(MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVHstorezero [off1+off2] {sym} ptr mem)
(MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVWstorezero [off1+off2] {sym} ptr mem)
(MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(off1+off2) => (MOVVstorezero [off1+off2] {sym} ptr mem)

// stores
(Store {t} ptr val mem) && t.(*types.Type).Size() == 1 => (MOVBstore ptr val mem)
(Store {t} ptr val mem) && t.(*types.Type).Size() == 2 => (MOVHstore ptr val mem)
(Store {t} ptr val mem) && t.(*types.Type).Size() == 4 && !is32BitFloat(val.Type) => (MOVWstore ptr val mem)
(Store {t} ptr val mem) && t.(*types.Type).Size() == 8 && !is64BitFloat(val.Type) => (MOVVstore ptr val mem)
(Store {t} ptr val mem) && t.(*types.Type).Size() == 4 && is32BitFloat(val.Type) => (MOVFstore ptr val mem)
(Store {t} ptr val mem) && t.(*types.Type).Size() == 8 && is64BitFloat(val.Type) => (MOVDstore ptr val mem)

// zeroing
(Zero [0] _ mem) => mem
(Zero [1] ptr mem) => (MOVBstore ptr (MOVVconst [0]) mem)
(Zero [2] {t} ptr mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore ptr (MOVVconst [0]) mem)
(Zero [2] ptr mem) =>
        (MOVBstore [1] ptr (MOVVconst [0])
                (MOVBstore [0] ptr (MOVVconst [0]) mem))
(Zero [4] {t} ptr mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore ptr (MOVVconst [0]) mem)
(Zero [4] {t} ptr mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [2] ptr (MOVVconst [0])
                (MOVHstore [0] ptr (MOVVconst [0]) mem))

(Zero [4] ptr mem) =>
        (MOVBstore [3] ptr (MOVVconst [0])
                (MOVBstore [2] ptr (MOVVconst [0])
                        (MOVBstore [1] ptr (MOVVconst [0])
                                (MOVBstore [0] ptr (MOVVconst [0]) mem))))
(Zero [8] {t} ptr mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore ptr (MOVVconst [0]) mem)
(Zero [8] {t} ptr mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore [4] ptr (MOVVconst [0])
                (MOVWstore [0] ptr (MOVVconst [0]) mem))
(Zero [8] {t} ptr mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [6] ptr (MOVVconst [0])
                (MOVHstore [4] ptr (MOVVconst [0])
                        (MOVHstore [2] ptr (MOVVconst [0])
                                (MOVHstore [0] ptr (MOVVconst [0]) mem))))

(Zero [3] ptr mem) =>
        (MOVBstore [2] ptr (MOVVconst [0])
                (MOVBstore [1] ptr (MOVVconst [0])
                        (MOVBstore [0] ptr (MOVVconst [0]) mem)))
(Zero [6] {t} ptr mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [4] ptr (MOVVconst [0])
                (MOVHstore [2] ptr (MOVVconst [0])
                        (MOVHstore [0] ptr (MOVVconst [0]) mem)))
(Zero [12] {t} ptr mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore [8] ptr (MOVVconst [0])
                (MOVWstore [4] ptr (MOVVconst [0])
                        (MOVWstore [0] ptr (MOVVconst [0]) mem)))
(Zero [16] {t} ptr mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore [8] ptr (MOVVconst [0])
                (MOVVstore [0] ptr (MOVVconst [0]) mem))
(Zero [24] {t} ptr mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore [16] ptr (MOVVconst [0])
                (MOVVstore [8] ptr (MOVVconst [0])
                        (MOVVstore [0] ptr (MOVVconst [0]) mem)))

// medium zeroing uses a duff device
// 8, and 128 are magic constants, see runtime/mkduff.go
(Zero [s] {t} ptr mem)
        && s%8 == 0 && s > 24 && s <= 8*128
        && t.(*types.Type).Alignment()%8 == 0 && !config.noDuffDevice =>
        (DUFFZERO [8 * (128 - int64(s/8))] ptr mem)

// large or unaligned zeroing uses a loop
(Zero [s] {t} ptr mem)
        && (s > 8*128 || config.noDuffDevice) || t.(*types.Type).Alignment()%8 != 0 =>
        (LoweredZero [t.(*types.Type).Alignment()]
                ptr
                (ADDVconst <ptr.Type> ptr [s-moveSize(t.(*types.Type).Alignment(), config)])
                mem)

// moves
(Move [0] _ _ mem) => mem
(Move [1] dst src mem) => (MOVBstore dst (MOVBload src mem) mem)
(Move [2] {t} dst src mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore dst (MOVHload src mem) mem)
(Move [2] dst src mem) =>
        (MOVBstore [1] dst (MOVBload [1] src mem)
                (MOVBstore dst (MOVBload src mem) mem))
(Move [4] {t} dst src mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore dst (MOVWload src mem) mem)
(Move [4] {t} dst src mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [2] dst (MOVHload [2] src mem)
                (MOVHstore dst (MOVHload src mem) mem))

(Move [4] dst src mem) =>
        (MOVBstore [3] dst (MOVBload [3] src mem)
                (MOVBstore [2] dst (MOVBload [2] src mem)
                        (MOVBstore [1] dst (MOVBload [1] src mem)
                                (MOVBstore dst (MOVBload src mem) mem))))
(Move [8] {t} dst src mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore dst (MOVVload src mem) mem)
(Move [8] {t} dst src mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore [4] dst (MOVWload [4] src mem)
                (MOVWstore dst (MOVWload src mem) mem))
(Move [8] {t} dst src mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [6] dst (MOVHload [6] src mem)
                (MOVHstore [4] dst (MOVHload [4] src mem)
                        (MOVHstore [2] dst (MOVHload [2] src mem)
                                (MOVHstore dst (MOVHload src mem) mem))))

(Move [3] dst src mem) =>
        (MOVBstore [2] dst (MOVBload [2] src mem)
                (MOVBstore [1] dst (MOVBload [1] src mem)
                        (MOVBstore dst (MOVBload src mem) mem)))
(Move [6] {t} dst src mem) && t.(*types.Type).Alignment()%2 == 0 =>
        (MOVHstore [4] dst (MOVHload [4] src mem)
                (MOVHstore [2] dst (MOVHload [2] src mem)
                        (MOVHstore dst (MOVHload src mem) mem)))
(Move [12] {t} dst src mem) && t.(*types.Type).Alignment()%4 == 0 =>
        (MOVWstore [8] dst (MOVWload [8] src mem)
                (MOVWstore [4] dst (MOVWload [4] src mem)
                        (MOVWstore dst (MOVWload src mem) mem)))
(Move [16] {t} dst src mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore [8] dst (MOVVload [8] src mem)
                (MOVVstore dst (MOVVload src mem) mem))
(Move [24] {t} dst src mem) && t.(*types.Type).Alignment()%8 == 0 =>
        (MOVVstore [16] dst (MOVVload [16] src mem)
                (MOVVstore [8] dst (MOVVload [8] src mem)
                        (MOVVstore dst (MOVVload src mem) mem)))

// large or unaligned move uses a loop
(Move [s] {t} dst src mem)
        && s > 24 || t.(*types.Type).Alignment()%8 != 0 =>
        (LoweredMove [t.(*types.Type).Alignment()]
                dst
                src
                (ADDVconst <src.Type> src [s-moveSize(t.(*types.Type).Alignment(), config)])
                mem)


// calls
(StaticCall [argwid] {target} mem) => (CALLstatic [argwid] {target} mem)
(ClosureCall [argwid] entry closure mem) => (CALLclosure [argwid] entry closure mem)
(InterCall [argwid] entry mem) => (CALLinter [argwid] entry mem)

// checks
(NilCheck ...) => (LoweredNilCheck ...)
//(IsNonNil ptr) => (Greater64U   ptr (MOVVconst [0]))
(IsNonNil ptr) => (CMPULT (MOVVconst [0]) ptr)
(IsInBounds ...) => (CMPULT ...)
(IsSliceInBounds ...) => (CMPULE ...)


// fold constant into arithmatic ops
(ADDV x (MOVVconst [c])) && is32Bit(c) => (ADDVconst [c] x)
(SUBV x (MOVVconst [c])) && is32Bit(c) => (SUBVconst [c] x)
(MULW x (MOVVconst [c])) && is32Bit(c) => (MULWconst [c] x)
(MULL x (MOVVconst [c]))  => (MULLconst [c] x)
(AND x (MOVVconst [c])) && is32Bit(c) => (ANDconst [c] x)
(BIS  x (MOVVconst [c])) && is32Bit(c) => (BISconst  [c] x)
(XOR x (MOVVconst [c])) && is32Bit(c) => (XORconst [c] x)
(ORNOT x (MOVVconst [c])) && is32Bit(c) => (ORNOTconst [c] x)

(CMPEQ x (MOVVconst [c])) && is32Bit(c) => (CMPEQconst [c] x)
(CMPLT x (MOVVconst [c])) && is32Bit(c) => (CMPLTconst [c] x)
(CMPLE x (MOVVconst [c])) && is32Bit(c) => (CMPLEconst [c] x)
(CMPULT x (MOVVconst [c])) && is32Bit(c) => (CMPULTconst [c] x)
(CMPULE x (MOVVconst [c])) && is32Bit(c) => (CMPULEconst [c] x)

(SEXTB  (MOVVconst [c])) => (MOVVconst [int64(int8(c))])
(ANDconst  (MOVVconst [c]) [255]) => (MOVVconst [int64(uint8(c))])
(SEXTH  (MOVVconst [c])) => (MOVVconst [int64(int16(c))])
(ANDconst (MOVVconst [c]) [65535]) => (MOVVconst [int64(uint16(c))])
(ADDWconst  (MOVVconst [c]) [0]) => (MOVVconst [int64(int32(c))])
(ANDconst (MOVVconst [c]) [0xffffffff])  => (MOVVconst [int64(uint32(c))])

// generic simplifications
(ADDV x (NEGV y)) => (SUBV x y)
(SUBV x x) => (MOVVconst [0])
(SUBV (MOVVconst [0]) x) => (NEGV x)
(AND x x) => x
(BIS  x x) => x
(XOR x x) => (MOVVconst [0])


// remove redundant *const ops
(ADDVconst [0]  x) => x
(SUBVconst [0]  x) => x
(ANDconst [0]  _) => (MOVVconst [0])
(ANDconst [-1] x) => x
(BISconst  [0]  x) => x
(BISconst  [-1] _) => (MOVVconst [-1])
(XORconst [0]  x) => x

// generic constant folding
(ADDVconst [c] (MOVVconst [d]))  => (MOVVconst [c+d])
(ADDVconst [c] (ADDVconst [d] x)) && is32Bit(c+d) => (ADDVconst [c+d] x)
(ADDVconst [c] (SUBVconst [d] x)) && is32Bit(c-d) => (ADDVconst [c-d] x)
(SUBVconst [c] (MOVVconst [d]))  => (MOVVconst [d-c])
(SUBVconst [c] (SUBVconst [d] x)) && is32Bit(-c-d) => (ADDVconst [-c-d] x)
(SUBVconst [c] (ADDVconst [d] x)) && is32Bit(-c+d) => (ADDVconst [-c+d] x)
(SLLconst [c] (MOVVconst [d]))  => (MOVVconst [int64(d)<<uint64(c)])
(SRLconst [c] (MOVVconst [d]))  => (MOVVconst [int64(uint64(d)>>uint64(c))])
(SRAconst [c] (MOVVconst [d]))  => (MOVVconst [int64(d)>>uint64(c)])
(ANDconst [c] (MOVVconst [d])) => (MOVVconst [c&d])
(ANDconst [c] (ANDconst [d] x)) => (ANDconst [c&d] x)
(BISconst [c] (MOVVconst [d])) => (MOVVconst [c|d])
(BISconst [c] (BISconst [d] x)) && is32Bit(c|d) => (BISconst [c|d] x)
(XORconst [c] (MOVVconst [d])) => (MOVVconst [c^d])
(XORconst [c] (XORconst [d] x)) && is32Bit(c^d) => (XORconst [c^d] x)
(NEGV (MOVVconst [c])) => (MOVVconst [-c])


// fold offset into address
(ADDVconst [off1] (SYMADDR [off2] {sym} ptr)) => (SYMADDR [off1+off2] {sym} ptr)

// fold address into load/store
(MOVBload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVBload  [off1+off2] {sym} ptr mem)
(MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVBUload [off1+off2] {sym} ptr mem)
(MOVHload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVHload  [off1+off2] {sym} ptr mem)
(MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVHUload [off1+off2] {sym} ptr mem)
(MOVWload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVWload  [off1+off2] {sym} ptr mem)
(MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVWUload [off1+off2] {sym} ptr mem)
(MOVVload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVVload  [off1+off2] {sym} ptr mem)
(MOVFload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVFload  [off1+off2] {sym} ptr mem)
(MOVDload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVDload  [off1+off2] {sym} ptr mem)

(MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVBstore [off1+off2] {sym} ptr val mem)
(MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVHstore [off1+off2] {sym} ptr val mem)
(MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVWstore [off1+off2] {sym} ptr val mem)
(MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVVstore [off1+off2] {sym} ptr val mem)
(MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVFstore [off1+off2] {sym} ptr val mem)
(MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(off1+off2) => (MOVDstore [off1+off2] {sym} ptr val mem)
(MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVBstorezero [off1+off2] {sym} ptr mem)
(MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVHstorezero [off1+off2] {sym} ptr mem)
(MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVWstorezero [off1+off2] {sym} ptr mem)
(MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(off1+off2) => (MOVVstorezero [off1+off2] {sym} ptr mem)

(MOVBload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVBload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVBUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVBUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVHload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVHUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVHUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVWload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVWUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVWUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVVload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVVload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVFload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVFload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVDload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)


(MOVBstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVHstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVWstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVVstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVVstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVFstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVFstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVDstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
(MOVBstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVBstorezero [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVHstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVHstorezero [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVWstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVWstorezero [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
(MOVVstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) && is32Bit(off1+off2) =>
        (MOVVstorezero [off1+off2] {mergeSym(sym1,sym2)} ptr mem)


// store zero
(MOVBstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVBstorezero [off] {sym} ptr mem)
(MOVHstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVHstorezero [off] {sym} ptr mem)
(MOVWstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVWstorezero [off] {sym} ptr mem)
(MOVVstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVVstorezero [off] {sym} ptr mem)

(If cond yes no) => (NE cond yes no)

(NE (XORconst cmp:(CMPEQ _ _) [1]) yes no) => (EQ cmp yes no)
(EQ (XORconst cmp:(CMPEQ _ _) [1]) yes no) => (NE cmp yes no)
(NE (XORconst cmp:(CMPEQconst _) [1]) yes no) => (EQ cmp yes no)
(EQ (XORconst cmp:(CMPEQconst _) [1]) yes no) => (NE cmp yes no)

(NE (CMPEQconst x [0]) yes no) => (EQ x yes no)
(EQ (CMPEQconst x [0]) yes no) => (NE x yes no)
(NE (CMPLTconst x [0]) yes no) => (LT x yes no)
(EQ (CMPLTconst x [0]) yes no) => (GE x yes no)
(NE (CMPLEconst x [0]) yes no) => (LE x yes no)
(EQ (CMPLEconst x [0]) yes no) => (GT x yes no)
(NE (CMPLTconst x [1]) yes no) => (LE x yes no)
(EQ (CMPLTconst x [1]) yes no) => (GT x yes no)
(NE (CMPULTconst x [1]) yes no) => (EQ x yes no)
(EQ (CMPULTconst x [1]) yes no) => (NE x yes no)
(NE (CMPULEconst x [0]) yes no) => (EQ x yes no)
(EQ (CMPULEconst x [0]) yes no) => (NE x yes no)

(NE (CMPEQ x (MOVVconst [0])) yes no) => (EQ x yes no)
(EQ (CMPEQ x (MOVVconst [0])) yes no) => (NE x yes no)
(NE (CMPLT x (MOVVconst [0])) yes no) => (LT x yes no)
(EQ (CMPLT x (MOVVconst [0])) yes no) => (GE x yes no)
(NE (CMPLT x (MOVVconst [1])) yes no) => (LE x yes no)
(EQ (CMPLT x (MOVVconst [1])) yes no) => (GT x yes no)
(NE (CMPLE x (MOVVconst [0])) yes no) => (LE x yes no)
(EQ (CMPLE x (MOVVconst [0])) yes no) => (GT x yes no)
(NE (CMPULT x (MOVVconst [1])) yes no) => (EQ x yes no)
(EQ (CMPULT x (MOVVconst [1])) yes no) => (NE x yes no)
(NE (CMPULE x (MOVVconst [0])) yes no) => (EQ x yes no)
(EQ (CMPULE x (MOVVconst [0])) yes no) => (NE x yes no)
(NE (CMPEQ (MOVVconst [0]) x) yes no) => (EQ x yes no)
(EQ (CMPEQ (MOVVconst [0]) x) yes no) => (NE x yes no)
(NE (CMPLT (MOVVconst [0]) x) yes no) => (GT x yes no)
(EQ (CMPLT (MOVVconst [0]) x) yes no) => (LE x yes no)
(NE (CMPLE (MOVVconst [0]) x) yes no) => (GE x yes no)
(EQ (CMPLE (MOVVconst [0]) x) yes no) => (LT x yes no)
(NE (CMPLE (MOVVconst [1]) x) yes no) => (GT x yes no)
(EQ (CMPLE (MOVVconst [1]) x) yes no) => (LE x yes no)
(NE (CMPULT (MOVVconst [0]) x) yes no) => (NE x yes no)
(EQ (CMPULT (MOVVconst [0]) x) yes no) => (EQ x yes no)
(NE (CMPULE (MOVVconst [1]) x) yes no) => (NE x yes no)
(EQ (CMPULE (MOVVconst [1]) x) yes no) => (EQ x yes no)

(NE (FNotEqual cmp) yes no) => (FEQ cmp yes no)
(NE (FEqual cmp) yes no) => (FNE cmp yes no)
(EQ (FNotEqual cmp) yes no) => (FNE cmp yes no)
(EQ (FEqual cmp) yes no) => (FEQ cmp yes no)

(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 => (LoweredPanicBoundsA [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 => (LoweredPanicBoundsB [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 => (LoweredPanicBoundsC [kind] x y mem)

// rotates
(RotateLeft8 <t> x (MOVVconst [c])) => (Or8 (Lsh8x64 <t> x (MOVVconst [c&7])) (Rsh8Ux64 <t> x (MOVVconst [-c&7])))
(RotateLeft16 <t> x (MOVVconst [c])) => (Or16 (Lsh16x64 <t> x (MOVVconst [c&15])) (Rsh16Ux64 <t> x (MOVVconst [-c&15])))
(RotateLeft32 <t> x (MOVVconst [c])) => (Or32 (Lsh32x64 <t> x (MOVVconst [c&31])) (Rsh32Ux64 <t> x (MOVVconst [-c&31])))
(RotateLeft64 <t> x (MOVVconst [c])) => (Or64 (Lsh64x64 <t> x (MOVVconst [c&63])) (Rsh64Ux64 <t> x (MOVVconst [-c&63])))

// atomic intrinsics
(AtomicLoad(8|32|64) ...) => (LoweredAtomicLoad(8|32|64) ...)
(AtomicLoadPtr ...) => (LoweredAtomicLoad64 ...)

(AtomicStore(8|32|64) ...) => (LoweredAtomicStore(8|32|64) ...)
(AtomicStorePtrNoWB ...) => (LoweredAtomicStore64 ...)

(AtomicExchange(32|64) ...) => (LoweredAtomicExchange(32|64) ...)

(AtomicAdd(32|64) ...) => (LoweredAtomicAdd(32|64) ...)

(AtomicCompareAndSwap(32|64) ...) => (LoweredAtomicCas(32|64) ...)
