// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/jx/work/src/golang/go-sw64-1.16.4/src/runtime/testdata/testprogcgo/lockosthread.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !plan9,!windows

package main

import (
	"os"
	"runtime"
	"sync/atomic"
	"time"
	"unsafe"
)

/*
#include <pthread.h>
#include <stdint.h>

extern uint32_t threadExited;

void setExited(void *x);
*/
import _ "unsafe"

var mainThread  /*line :27:16*/_Ctype_pthread_t /*line :27:27*/

func init() {
	registerInit("LockOSThreadMain", func() {
		// init is guaranteed to run on the main thread.
		mainThread = ( /*line :32:16*/_Cfunc_pthread_self /*line :32:29*/)()
	})
	register("LockOSThreadMain", LockOSThreadMain)

	registerInit("LockOSThreadAlt", func() {
		// Lock the OS thread now so main runs on the main thread.
		runtime.LockOSThread()
	})
	register("LockOSThreadAlt", LockOSThreadAlt)
}

func LockOSThreadMain() {
	// This requires GOMAXPROCS=1 from the beginning to reliably
	// start a goroutine on the main thread.
	if runtime.GOMAXPROCS(-1) != 1 {
		println("requires GOMAXPROCS=1")
		os.Exit(1)
	}

	ready := make(chan bool, 1)
	go func() {
		// Because GOMAXPROCS=1, this *should* be on the main
		// thread. Stay there.
		runtime.LockOSThread()
		self := ( /*line :56:11*/_Cfunc_pthread_self /*line :56:24*/)()
		if ( /*line :57:6*/_Cfunc_pthread_equal /*line :57:20*/)(mainThread, self) == 0 {
			println("failed to start goroutine on main thread")
			os.Exit(1)
		}
		// Exit with the thread locked, which should exit the
		// main thread.
		ready <- true
	}()
	<-ready
	time.Sleep(1 * time.Millisecond)
	// Check that this goroutine is still running on a different
	// thread.
	self := ( /*line :69:10*/_Cfunc_pthread_self /*line :69:23*/)()
	if ( /*line :70:5*/_Cfunc_pthread_equal /*line :70:19*/)(mainThread, self) != 0 {
		println("goroutine migrated to locked thread")
		os.Exit(1)
	}
	println("OK")
}

func LockOSThreadAlt() {
	// This is running locked to the main OS thread.

	var subThread  /*line :80:16*/_Ctype_pthread_t /*line :80:27*/
	ready := make(chan bool, 1)
	( /*line :82:2*/*_Cvar_threadExited /*line :82:15*/) = 0
	go func() {
		// This goroutine must be running on a new thread.
		runtime.LockOSThread()
		subThread = ( /*line :86:15*/_Cfunc_pthread_self /*line :86:28*/)()
		// Register a pthread destructor so we can tell this
		// thread has exited.
		var key  /*line :89:11*/_Ctype_pthread_key_t /*line :89:26*/
		( /*line :90:3*/_Cfunc_pthread_key_create /*line :90:22*/)(&key, (*[0]byte)(unsafe.Pointer(( /*line :90:56*/_Cgo_ptr(_Cfpvar_fp_setExited) /*line :90:66*/))))
		func() _Ctype_int{ var _cgo0 _Ctype_pthread_key_t = /*line :91:25*/key; _cgo1 := /*line :91:30*/unsafe.Pointer(new(int)); _cgoCheckPointer(_cgo1, nil); return _Cfunc_pthread_setspecific(_cgo0, _cgo1); }()
		ready <- true
		// Exit with the thread locked.
	}()
	<-ready
	for i := 0; i < 100; i++ {
		time.Sleep(1 * time.Millisecond)
		// Check that this goroutine is running on a different thread.
		self := ( /*line :99:11*/_Cfunc_pthread_self /*line :99:24*/)()
		if ( /*line :100:6*/_Cfunc_pthread_equal /*line :100:20*/)(subThread, self) != 0 {
			println("locked thread reused")
			os.Exit(1)
		}
		if atomic.LoadUint32((*uint32)(&( /*line :104:35*/*_Cvar_threadExited /*line :104:48*/))) != 0 {
			println("OK")
			return
		}
	}
	println("sub thread still running")
	os.Exit(1)
}
