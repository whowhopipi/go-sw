// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/jx/work/src/golang/go-sw64-1.16.4/misc/cgo/test/test.go:1:1
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test cases for cgo.
// Both the import "C" prologue and the main file are sorted by issue number.
// This file contains C definitions (not just declarations)
// and so it must NOT contain any //export directives on Go functions.
// See testx.go for exports.

package cgotest; import _cgo_unsafe "unsafe"

/*
#include <complex.h>
#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#cgo LDFLAGS: -lm

#ifndef WIN32
#include <pthread.h>
#include <signal.h>
#endif

// alignment tests

typedef unsigned char Uint8;
typedef unsigned short Uint16;

typedef enum {
 MOD1 = 0x0000,
 MODX = 0x8000
} SDLMod;

typedef enum {
 A1 = 1,
 B1 = 322,
 SDLK_LAST
} SDLKey;

typedef struct SDL_keysym {
	Uint8 scancode;
	SDLKey sym;
	SDLMod mod;
	Uint16 unicode;
} SDL_keysym;

typedef struct SDL_KeyboardEvent {
	Uint8 typ;
	Uint8 which;
	Uint8 state;
	SDL_keysym keysym;
} SDL_KeyboardEvent;

void makeEvent(SDL_KeyboardEvent *event) {
 unsigned char *p;
 int i;

 p = (unsigned char*)event;
 for (i=0; i<sizeof *event; i++) {
   p[i] = i;
 }
}

int same(SDL_KeyboardEvent* e, Uint8 typ, Uint8 which, Uint8 state, Uint8 scan, SDLKey sym, SDLMod mod, Uint16 uni) {
  return e->typ == typ && e->which == which && e->state == state && e->keysym.scancode == scan && e->keysym.sym == sym && e->keysym.mod == mod && e->keysym.unicode == uni;
}

void cTest(SDL_KeyboardEvent *event) {
 printf("C: %#x %#x %#x %#x %#x %#x %#x\n", event->typ, event->which, event->state,
   event->keysym.scancode, event->keysym.sym, event->keysym.mod, event->keysym.unicode);
 fflush(stdout);
}

// api

const char *greeting = "hello, world";

// basic test cases

#define SHIFT(x, y)  ((x)<<(y))
#define KILO SHIFT(1, 10)
#define UINT32VAL 0xc008427bU

enum E {
	Enum1 = 1,
	Enum2 = 2,
};

typedef unsigned char cgo_uuid_t[20];

void uuid_generate(cgo_uuid_t x) {
	x[0] = 0;
}

struct S {
	int x;
};

const char *cstr = "abcefghijklmnopqrstuvwxyzABCEFGHIJKLMNOPQRSTUVWXYZ1234567890";

extern enum E myConstFunc(struct S* const ctx, int const id, struct S **const filter);

enum E myConstFunc(struct S *const ctx, int const id, struct S **const filter) { return 0; }

int add(int x, int y) {
	return x+y;
};

// Following mimicks vulkan complex definitions for benchmarking cgocheck overhead.

typedef uint32_t VkFlags;
typedef VkFlags  VkDeviceQueueCreateFlags;
typedef uint32_t VkStructureType;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkPhysicalDeviceFeatures {
    uint32_t bools[56];
} VkPhysicalDeviceFeatures;

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkFlags                            flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

void handleComplexPointer(VkDeviceCreateInfo *a0) {}
void handleComplexPointer8(
	VkDeviceCreateInfo *a0, VkDeviceCreateInfo *a1, VkDeviceCreateInfo *a2, VkDeviceCreateInfo *a3,
	VkDeviceCreateInfo *a4, VkDeviceCreateInfo *a5, VkDeviceCreateInfo *a6, VkDeviceCreateInfo *a7
) {}

// complex alignment

struct {
	float x;
	_Complex float y;
} cplxAlign = { 3.14, 2.17 };

// constants and pointer checking

#define CheckConstVal 0

typedef struct {
	int *p;
} CheckConstStruct;

static void CheckConstFunc(CheckConstStruct *p, int e) {}

// duplicate symbol

int base_symbol = 0;
#define alias_one base_symbol
#define alias_two base_symbol

// function pointer variables

typedef int (*intFunc) ();

int
bridge_int_func(intFunc f)
{
	return f();
}

int fortytwo()
{
	return 42;
}

// issue 1222
typedef union {
	long align;
} xxpthread_mutex_t;
struct ibv_async_event {
	union {
		int x;
	} element;
};
struct ibv_context {
	xxpthread_mutex_t mutex;
};

// issue 1635
// Mac OS X's gcc will generate scattered relocation 2/1 for
// this function on Darwin/386, and 8l couldn't handle it.
// this example is in issue 1635
void scatter() {
	void *p = scatter;
	printf("scatter = %p\n", p);
}

// Adding this explicit extern declaration makes this a test for
// https://gcc.gnu.org/PR68072 aka https://golang.org/issue/13344 .
// It used to cause a cgo error when building with GCC 6.
extern int hola;

// this example is in issue 3253
int hola = 0;
int testHola() { return hola; }

// issue 3250
#ifdef WIN32
void testSendSIG() {}
#else
static void *thread(void *p) {
	const int M = 100;
	int i;
	(void)p;
	for (i = 0; i < M; i++) {
		pthread_kill(pthread_self(), SIGCHLD);
		usleep(rand() % 20 + 5);
	}
	return NULL;
}
void testSendSIG() {
	const int N = 20;
	int i;
	pthread_t tid[N];
	for (i = 0; i < N; i++) {
		usleep(rand() % 200 + 100);
		pthread_create(&tid[i], 0, thread, NULL);
	}
	for (i = 0; i < N; i++)
		pthread_join(tid[i], 0);
}
#endif

// issue 3261
// libgcc on ARM might be compiled as thumb code, but our 5l
// can't handle that, so we have to disable this test on arm.
#ifdef __ARMEL__
int vabs(int x) {
	puts("testLibgcc is disabled on ARM because 5l cannot handle thumb library.");
	return (x < 0) ? -x : x;
}
#elif defined(__arm64__) && defined(__clang__)
int vabs(int x) {
	puts("testLibgcc is disabled on ARM64 with clang due to lack of libgcc.");
	return (x < 0) ? -x : x;
}
#else
int __absvsi2(int); // dummy prototype for libgcc function
// we shouldn't name the function abs, as gcc might use
// the builtin one.
int vabs(int x) { return __absvsi2(x); }
#endif


// issue 3729
// access errno from void C function
const char _expA = 0x42;
const float _expB = 3.14159;
const short _expC = 0x55aa;
const int _expD = 0xdeadbeef;

#ifdef WIN32
void g(void) {}
void g2(int x, char a, float b, short c, int d) {}
#else

void g(void) {
	errno = E2BIG;
}

// try to pass some non-trivial arguments to function g2
void g2(int x, char a, float b, short c, int d) {
	if (a == _expA && b == _expB && c == _expC && d == _expD)
		errno = x;
	else
		errno = -1;
}
#endif

// issue 3945
// Test that cgo reserves enough stack space during cgo call.
// See https://golang.org/issue/3945 for details.
void say() {
	printf("%s from C\n", "hello");
}

// issue 4054 part 1 - other half in testx.go

typedef enum {
	A = 0,
	B,
	C,
	D,
	E,
	F,
	G,
	H,
	II,
	J,
} issue4054a;

// issue 4339
// We've historically permitted #include <>, so test it here.  Issue 29333.
// Also see issue 41059.
#include <issue4339.h>

// issue 4417
// cmd/cgo: bool alignment/padding issue.
// bool alignment is wrong and causing wrong arguments when calling functions.
static int c_bool(bool a, bool b, int c, bool d, bool e)  {
   return c;
}

// issue 4857
#cgo CFLAGS: -Werror
const struct { int a; } *issue4857() { return (void *)0; }

// issue 5224
// Test that the #cgo CFLAGS directive works,
// with and without platform filters.
#cgo CFLAGS: -DCOMMON_VALUE=123
#cgo windows CFLAGS: -DIS_WINDOWS=1
#cgo !windows CFLAGS: -DIS_WINDOWS=0
int common = COMMON_VALUE;
int is_windows = IS_WINDOWS;

// issue 5227
// linker incorrectly treats common symbols and
// leaves them undefined.

typedef struct {
        int Count;
} Fontinfo;

Fontinfo SansTypeface;

extern void init();

Fontinfo loadfont() {
        Fontinfo f = {0};
        return f;
}

void init() {
        SansTypeface = loadfont();
}

// issue 5242
// Cgo incorrectly computed the alignment of structs
// with no Go accessible fields as 0, and then panicked on
// modulo-by-zero computations.
typedef struct {
} foo;

typedef struct {
	int x : 1;
} bar;

int issue5242(foo f, bar b) {
	return 5242;
}

// issue 5337
// Verify that we can withstand SIGPROF received on foreign threads

#ifdef WIN32
void test5337() {}
#else
static void *thread1(void *p) {
	(void)p;
	pthread_kill(pthread_self(), SIGPROF);
	return NULL;
}
void test5337() {
	pthread_t tid;
	pthread_create(&tid, 0, thread1, NULL);
	pthread_join(tid, 0);
}
#endif

// issue 5603

const long long issue5603exp = 0x12345678;
long long issue5603foo0() { return issue5603exp; }
long long issue5603foo1(void *p) { return issue5603exp; }
long long issue5603foo2(void *p, void *q) { return issue5603exp; }
long long issue5603foo3(void *p, void *q, void *r) { return issue5603exp; }
long long issue5603foo4(void *p, void *q, void *r, void *s) { return issue5603exp; }

// issue 5740

int test5740a(void), test5740b(void);

// issue 5986
static void output5986()
{
    int current_row = 0, row_count = 0;
    double sum_squares = 0;
    double d;
    do {
        if (current_row == 10) {
            current_row = 0;
        }
        ++row_count;
    }
    while (current_row++ != 1);
    d =  sqrt(sum_squares / row_count);
    printf("sqrt is: %g\n", d);
}

// issue 6128
// Test handling of #defined names in clang.
// NOTE: Must use hex, or else a shortcut for decimals
// in cgo avoids trying to pass this to clang.
#define X 0x1

// issue 6472
typedef struct
{
        struct
        {
            int x;
        } y[16];
} z;

// issue 6612
// Test new scheme for deciding whether C.name is an expression, type, constant.
// Clang silences some warnings when the name is a #defined macro, so test those too
// (even though we now use errors exclusively, not warnings).

void myfunc(void) {}
int myvar = 5;
const char *mytext = "abcdef";
typedef int mytype;
enum {
	myenum = 1234,
};

#define myfunc_def myfunc
#define myvar_def myvar
#define mytext_def mytext
#define mytype_def mytype
#define myenum_def myenum
#define myint_def 12345
#define myfloat_def 1.5
#define mystring_def "hello"

// issue 6907
char* Issue6907CopyString(_GoString_ s) {
	size_t n;
	const char *p;
	char *r;

	n = _GoStringLen(s);
	p = _GoStringPtr(s);
	r = malloc(n + 1);
	memmove(r, p, n);
	r[n] = '\0';
	return r;
}

// issue 7560
typedef struct {
	char x;
	long y;
} __attribute__((__packed__)) misaligned;

int
offset7560(void)
{
	return (uintptr_t)&((misaligned*)0)->y;
}

// issue 7786
// No runtime test, just make sure that typedef and struct/union/class are interchangeable at compile time.

struct test7786;
typedef struct test7786 typedef_test7786;
void f7786(struct test7786 *ctx) {}
void g7786(typedef_test7786 *ctx) {}

typedef struct body7786 typedef_body7786;
struct body7786 { int x; };
void b7786(struct body7786 *ctx) {}
void c7786(typedef_body7786 *ctx) {}

typedef union union7786 typedef_union7786;
void u7786(union union7786 *ctx) {}
void v7786(typedef_union7786 *ctx) {}

// issue 8092
// Test that linker defined symbols (e.g., text, data) don't
// conflict with C symbols.
char text[] = "text";
char data[] = "data";
char *ctext(void) { return text; }
char *cdata(void) { return data; }

// issue 8428
// Cgo inconsistently translated zero size arrays.

struct issue8428one {
	char b;
	char rest[];
};

struct issue8428two {
	void *p;
	char b;
	char rest[0];
	char pad;
};

struct issue8428three {
	char w[1][2][3][0];
	char x[2][3][0][1];
	char y[3][0][1][2];
	char z[0][1][2][3];
};

// issue 8331 part 1 - part 2 in testx.go
// A typedef of an unnamed struct is the same struct when
// #include'd twice.  No runtime test; just make sure it compiles.
#include "issue8331.h"

// issue 8368 and 8441
// Recursive struct definitions didn't work.
// No runtime test; just make sure it compiles.
typedef struct one one;
typedef struct two two;
struct one {
	two *x;
};
struct two {
	one *x;
};

// issue 8811

extern int issue8811Initialized;
extern void issue8811Init();

void issue8811Execute() {
	if(!issue8811Initialized)
		issue8811Init();
}

// issue 8945

typedef void (*PFunc8945)();
PFunc8945 func8945;

// issue 9557

struct issue9557_t {
  int a;
} test9557bar = { 42 };
struct issue9557_t *issue9557foo = &test9557bar;

// issue 10303
// Pointers passed to C were not marked as escaping (bug in cgo).

typedef int *intptr;

void setintstar(int *x) {
	*x = 1;
}

void setintptr(intptr x) {
	*x = 1;
}

void setvoidptr(void *x) {
	*(int*)x = 1;
}

typedef struct Struct Struct;
struct Struct {
	int *P;
};

void setstruct(Struct s) {
	*s.P = 1;
}

// issue 11925
// Structs with zero-length trailing fields are now padded by the Go compiler.

struct a11925 {
	int i;
	char a[0];
	char b[0];
};

struct b11925 {
	int i;
	char a[0];
	char b[];
};

// issue 12030
void issue12030conv(char *buf, double x) {
	sprintf(buf, "d=%g", x);
}

// issue 14838

int check_cbytes(char *b, size_t l) {
	int i;
	for (i = 0; i < l; i++) {
		if (b[i] != i) {
			return 0;
		}
	}
	return 1;
}

// issue 17065
// Test that C symbols larger than a page play nicely with the race detector.
int ii[65537];

// issue 17537
// The void* cast introduced by cgo to avoid problems
// with const/volatile qualifiers breaks C preprocessor macros that
// emulate functions.

typedef struct {
	int i;
} S17537;

int I17537(S17537 *p);

#define I17537(p) ((p)->i)

// Calling this function used to fail without the cast.
const int F17537(const char **p) {
	return **p;
}

// issue 17723
// API compatibility checks

typedef char *cstring_pointer;
static void cstring_pointer_fun(cstring_pointer dummy) { }
const char *api_hello = "hello!";

// Calling this function used to trigger an error from the C compiler
// (issue 18298).
void F18298(const void *const *p) {
}

// Test that conversions between typedefs work as they used to.
typedef const void *T18298_1;
struct S18298 { int i; };
typedef const struct S18298 *T18298_2;
void G18298(T18298_1 t) {
}

// issue 18126
// cgo check of void function returning errno.
void Issue18126C(void **p) {}

// issue 18720

#define HELLO "hello"
#define WORLD "world"
#define HELLO_WORLD HELLO "\000" WORLD

struct foo { char c; };
#define SIZE_OF(x) sizeof(x)
#define SIZE_OF_FOO SIZE_OF(struct foo)
#define VAR1 VAR
#define VAR var
int var = 5;

#define ADDR &var

#define CALL fn()
int fn(void) {
	return ++var;
}

// issue 20129

int issue20129 = 0;
typedef void issue20129Void;
issue20129Void issue20129Foo() {
	issue20129 = 1;
}
typedef issue20129Void issue20129Void2;
issue20129Void2 issue20129Bar() {
	issue20129 = 2;
}

// issue 20369
#define XUINT64_MAX        18446744073709551615ULL

// issue 21668
// Fail to guess the kind of the constant "x".
// No runtime test; just make sure it compiles.
const int x21668 = 42;

// issue 21708
#define CAST_TO_INT64 (int64_t)(-1)

// issue 21809
// Compile C `typedef` to go type aliases.

typedef long MySigned_t;
// tests alias-to-alias
typedef MySigned_t MySigned2_t;
long takes_long(long x) { return x * x; }
MySigned_t takes_typedef(MySigned_t x) { return x * x; }

// issue 22906

// It's going to be hard to include a whole real JVM to test this.
// So we'll simulate a really easy JVM using just the parts we need.
// This is the relevant part of jni.h.

struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;

typedef jobject jweak;

// Note: jvalue is already a non-pointer type due to it being a C union.

// issue 22958

typedef struct {
	unsigned long long f8  : 8;
	unsigned long long f16 : 16;
	unsigned long long f24 : 24;
	unsigned long long f32 : 32;
	unsigned long long f40 : 40;
	unsigned long long f48 : 48;
	unsigned long long f56 : 56;
	unsigned long long f64 : 64;
} issue22958Type;

// issue 23356
int a(void) { return 5; };
int r(void) { return 3; };

// issue 23720
typedef int *issue23720A;
typedef const int *issue23720B;
void issue23720F(issue23720B a) {}

// issue 24206
#if defined(__linux__) && defined(__x86_64__)
#include <sys/mman.h>
// Returns string with null byte at the last valid address
char* dangerousString1() {
	int pageSize = 4096;
	char *data = mmap(0, 2 * pageSize, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0);
	mprotect(data + pageSize,pageSize,PROT_NONE);
	int start = pageSize - 123 - 1; // last 123 bytes of first page + 1 null byte
	int i = start;
	for (; i < pageSize; i++) {
	data[i] = 'x';
	}
	data[pageSize -1 ] = 0;
	return data+start;
}

char* dangerousString2() {
	int pageSize = 4096;
	char *data = mmap(0, 3 * pageSize, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0);
	mprotect(data + 2 * pageSize,pageSize,PROT_NONE);
	int start = pageSize - 123 - 1; // last 123 bytes of first page + 1 null byte
	int i = start;
	for (; i < 2 * pageSize; i++) {
	data[i] = 'x';
	}
	data[2*pageSize -1 ] = 0;
	return data+start;
}
#else
char *dangerousString1() { return NULL; }
char *dangerousString2() { return NULL; }
#endif

// issue 26066
const unsigned long long int issue26066 = (const unsigned long long) -1;

// issue 26517
// Introduce two pointer types which are distinct, but have the same
// base type. Make sure that both of those pointer types get resolved
// correctly. Before the fix for 26517 if one of these pointer types
// was resolved before the other one was processed, the second one
// would never be resolved.
// Before this issue was fixed this test failed on Windows,
// where va_list expands to a named char* type.
typedef va_list TypeOne;
typedef char *TypeTwo;

// issue 28540

static void twoargs1(void *p, int n) {}
static void *twoargs2() { return 0; }
static int twoargs3(void * p) { return 0; }

// issue 28545
// Failed to add type conversion for negative constant.

static void issue28545F(char **p, int n, complex double a) {}

// issue 28772 part 1 - part 2 in testx.go
// Failed to add type conversion for Go constant set to C constant.
// No runtime test; just make sure it compiles.

#define issue28772Constant 1

// issue 28896
// cgo was incorrectly adding padding after a packed struct.
typedef struct {
	void *f1;
	uint32_t f2;
} __attribute__((__packed__)) innerPacked;

typedef struct {
	innerPacked g1;
	uint64_t g2;
} outerPacked;

typedef struct {
	void *f1;
	uint32_t f2;
} innerUnpacked;

typedef struct {
	innerUnpacked g1;
	uint64_t g2;
} outerUnpacked;

size_t offset(int x) {
	switch (x) {
	case 0:
		return offsetof(innerPacked, f2);
	case 1:
		return offsetof(outerPacked, g2);
	case 2:
		return offsetof(innerUnpacked, f2);
	case 3:
		return offsetof(outerUnpacked, g2);
	default:
		abort();
	}
}

// issue 29748

typedef struct { char **p; } S29748;
static int f29748(S29748 *p) { return 0; }

// issue 29781
// Error with newline inserted into constant expression.
// Compilation test only, nothing to run.

static void issue29781F(char **p, int n) {}
#define ISSUE29781C 0

// issue 31093
static uint16_t issue31093F(uint16_t v) { return v; }

// issue 32579
typedef struct S32579 { unsigned char data[1]; } S32579;

// issue 38649
// Test that #define'd type aliases work.
#define netbsd_gid unsigned int

// issue 40494
// Inconsistent handling of tagged enum and union types.
enum Enum40494 { X_40494 };
union Union40494 { int x; };
void issue40494(enum Enum40494 e, union Union40494* up) {}
*/
import _ "unsafe"

import (
	"context"
	"fmt"
	"math"
	"math/rand"
	"os"
	"os/signal"
	"reflect"
	"runtime"
	"sync"
	"syscall"
	"testing"
	"time"
	"unsafe"
)

// alignment

func testAlign(t *testing.T) {
	var evt  /*line :933:10*/_Ctype_SDL_KeyboardEvent /*line :933:29*/
	( /*line :934:2*/_Cfunc_makeEvent /*line :934:12*/)(&evt)
	if ( /*line :935:5*/_Cfunc_same /*line :935:10*/)(&evt, evt.typ, evt.which, evt.state, evt.keysym.scancode, evt.keysym.sym, evt.keysym.mod, evt.keysym.unicode) == 0 {
		t.Error("*** bad alignment")
		( /*line :937:3*/_Cfunc_cTest /*line :937:9*/)(&evt)
		t.Errorf("Go: %#x %#x %#x %#x %#x %#x %#x\n",
			evt.typ, evt.which, evt.state, evt.keysym.scancode,
			evt.keysym.sym, evt.keysym.mod, evt.keysym.unicode)
		t.Error(evt)
	}
}

// api

const greeting = "hello, world"

type testPair struct {
	Name      string
	Got, Want interface{}
}

var testPairs = []testPair{
	{"GoString", ( /*line :955:15*/_Cfunc_GoString /*line :955:24*/)(( /*line :955:26*/*_Cvar_greeting /*line :955:35*/)), greeting},
	{"GoStringN", ( /*line :956:16*/_Cfunc_GoStringN /*line :956:26*/)(( /*line :956:28*/*_Cvar_greeting /*line :956:37*/), 5), greeting[:5]},
	{"GoBytes", func() []byte{ _cgo0 := /*line :957:24*/unsafe.Pointer(*_Cvar_greeting); var _cgo1 _Ctype_int = /*line :957:52*/5; _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }(), []byte(greeting[:5])},
}

func testHelpers(t *testing.T) {
	for _, pair := range testPairs {
		if !reflect.DeepEqual(pair.Got, pair.Want) {
			t.Errorf("%s: got %#v, want %#v", pair.Name, pair.Got, pair.Want)
		}
	}
}

// basic test cases

const EINVAL = ( /*line :970:16*/_Ciconst_EINVAL /*line :970:23*/) /* test #define */

var KILO = ( /*line :972:12*/_Ciconst_KILO /*line :972:17*/)

func uuidgen() {
	var uuid  /*line :975:11*/_Ctype_cgo_uuid_t /*line :975:23*/
	( /*line :976:2*/_Cfunc_uuid_generate /*line :976:16*/)(&uuid[0])
}

func Strtol(s string, base int) (int, error) {
	p := ( /*line :980:7*/_Cfunc_CString /*line :980:15*/)(s)
	n, err := ( /*line :981:12*/_C2func_strtol /*line :981:19*/)(p, nil,  /*line :981:29*/_Ctype_int /*line :981:34*/(base))
	func() { _cgo0 := /*line :982:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	return int(n), err
}

func Atol(s string) int {
	p := ( /*line :987:7*/_Cfunc_CString /*line :987:15*/)(s)
	n := ( /*line :988:7*/_Cfunc_atol /*line :988:12*/)(p)
	func() { _cgo0 := /*line :989:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	return int(n)
}

func testConst(t *testing.T) {
	( /*line :994:2*/_Cfunc_myConstFunc /*line :994:14*/)(nil, 0, nil)
}

func testEnum(t *testing.T) {
	if ( /*line :998:5*/_Ciconst_Enum1 /*line :998:11*/) != 1 || ( /*line :998:21*/_Ciconst_Enum2 /*line :998:27*/) != 2 {
		t.Error("bad enum", ( /*line :999:23*/_Ciconst_Enum1 /*line :999:29*/), ( /*line :999:32*/_Ciconst_Enum2 /*line :999:38*/))
	}
}

func testNamedEnum(t *testing.T) {
	e := new( /*line :1004:11*/_Ctype_enum_E /*line :1004:19*/)

	*e = ( /*line :1006:7*/_Ciconst_Enum1 /*line :1006:13*/)
	if *e != 1 {
		t.Error("bad enum", ( /*line :1008:23*/_Ciconst_Enum1 /*line :1008:29*/))
	}

	*e = ( /*line :1011:7*/_Ciconst_Enum2 /*line :1011:13*/)
	if *e != 2 {
		t.Error("bad enum", ( /*line :1013:23*/_Ciconst_Enum2 /*line :1013:29*/))
	}
}

func testCastToEnum(t *testing.T) {
	e :=  /*line :1018:7*/_Ctype_enum_E /*line :1018:15*/(( /*line :1018:16*/_Ciconst_Enum1 /*line :1018:22*/))
	if e != 1 {
		t.Error("bad enum", ( /*line :1020:23*/_Ciconst_Enum1 /*line :1020:29*/))
	}

	e =  /*line :1023:6*/_Ctype_enum_E /*line :1023:14*/(( /*line :1023:15*/_Ciconst_Enum2 /*line :1023:21*/))
	if e != 2 {
		t.Error("bad enum", ( /*line :1025:23*/_Ciconst_Enum2 /*line :1025:29*/))
	}
}

func testAtol(t *testing.T) {
	l := Atol("123")
	if l != 123 {
		t.Error("Atol 123: ", l)
	}
}

func testErrno(t *testing.T) {
	p := ( /*line :1037:7*/_Cfunc_CString /*line :1037:15*/)("no-such-file")
	m := ( /*line :1038:7*/_Cfunc_CString /*line :1038:15*/)("r")
	f, err := ( /*line :1039:12*/_C2func_fopen /*line :1039:18*/)(p, m)
	func() { _cgo0 := /*line :1040:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :1041:9*/unsafe.Pointer(m); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	if err == nil {
		func() _Ctype_int{ _cgo0 := /*line :1043:12*/f; _cgoCheckPointer(_cgo0, nil); return _Cfunc_fclose(_cgo0); }()
		t.Fatalf("C.fopen: should fail")
	}
	if err != syscall.ENOENT {
		t.Fatalf("C.fopen: unexpected error: %v", err)
	}
}

func testMultipleAssign(t *testing.T) {
	p := ( /*line :1052:7*/_Cfunc_CString /*line :1052:15*/)("234")
	n, m := ( /*line :1053:10*/_Cfunc_strtol /*line :1053:17*/)(p, nil, 345), ( /*line :1053:33*/_Cfunc_strtol /*line :1053:40*/)(p, nil, 10)
	if runtime.GOOS == "openbsd" {
		// Bug in OpenBSD strtol(3) - base > 36 succeeds.
		if (n != 0 && n != 239089) || m != 234 {
			t.Fatal("Strtol x2: ", n, m)
		}
	} else if n != 0 || m != 234 {
		t.Fatal("Strtol x2: ", n, m)
	}
	func() { _cgo0 := /*line :1062:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
}

var (
	cuint  = ( /*line :1066:12*/_Ctype_uint /*line :1066:18*/)(0)
	culong  /*line :1067:9*/_Ctype_ulong /*line :1067:16*/
	cchar   /*line :1068:9*/_Ctype_char /*line :1068:15*/
)

type Context struct {
	ctx * /*line :1072:7*/_Ctype_struct_ibv_context /*line :1072:27*/
}

func benchCgoCall(b *testing.B) {
	b.Run("add-int", func(b *testing.B) {
		const x =  /*line :1077:13*/_Ctype_int /*line :1077:18*/(2)
		const y =  /*line :1078:13*/_Ctype_int /*line :1078:18*/(3)

		for i := 0; i < b.N; i++ {
			( /*line :1081:4*/_Cfunc_add /*line :1081:8*/)(x, y)
		}
	})

	b.Run("one-pointer", func(b *testing.B) {
		var a0  /*line :1086:10*/_Ctype_VkDeviceCreateInfo /*line :1086:30*/
		for i := 0; i < b.N; i++ {
			func() { _cgoBase0 := /*line :1088:27*/&a0; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_handleComplexPointer(_cgo0); }()
		}
	})
	b.Run("eight-pointers", func(b *testing.B) {
		var a0, a1, a2, a3, a4, a5, a6, a7  /*line :1092:38*/_Ctype_VkDeviceCreateInfo /*line :1092:58*/
		for i := 0; i < b.N; i++ {
			func() { _cgoBase0 := /*line :1094:28*/&a0; _cgo0 := _cgoBase0; _cgoBase1 := /*line :1094:33*/&a1; _cgo1 := _cgoBase1; _cgoBase2 := /*line :1094:38*/&a2; _cgo2 := _cgoBase2; _cgoBase3 := /*line :1094:43*/&a3; _cgo3 := _cgoBase3; _cgoBase4 := /*line :1094:48*/&a4; _cgo4 := _cgoBase4; _cgoBase5 := /*line :1094:53*/&a5; _cgo5 := _cgoBase5; _cgoBase6 := /*line :1094:58*/&a6; _cgo6 := _cgoBase6; _cgoBase7 := /*line :1094:63*/&a7; _cgo7 := _cgoBase7; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); _cgoCheckPointer(_cgoBase6, 0 == 0); _cgoCheckPointer(_cgoBase7, 0 == 0); _Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-nil", func(b *testing.B) {
		var a0, a1, a2, a3, a4, a5, a6, a7 * /*line :1098:39*/_Ctype_VkDeviceCreateInfo /*line :1098:59*/
		for i := 0; i < b.N; i++ {
			func() { _cgo0 := /*line :1100:28*/a0; _cgo1 := /*line :1100:32*/a1; _cgo2 := /*line :1100:36*/a2; _cgo3 := /*line :1100:40*/a3; _cgo4 := /*line :1100:44*/a4; _cgo5 := /*line :1100:48*/a5; _cgo6 := /*line :1100:52*/a6; _cgo7 := /*line :1100:56*/a7; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgo5, nil); _cgoCheckPointer(_cgo6, nil); _cgoCheckPointer(_cgo7, nil); _Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-array", func(b *testing.B) {
		var a [8] /*line :1104:12*/_Ctype_VkDeviceCreateInfo /*line :1104:32*/
		for i := 0; i < b.N; i++ {
			func() { _cgoIndex0 := &/*line :1106:29*/a; _cgo0 := /*line :1106:28*/&(*_cgoIndex0)[0]; _cgoIndex1 := &/*line :1106:36*/a; _cgo1 := /*line :1106:35*/&(*_cgoIndex1)[1]; _cgoIndex2 := &/*line :1106:43*/a; _cgo2 := /*line :1106:42*/&(*_cgoIndex2)[2]; _cgoIndex3 := &/*line :1106:50*/a; _cgo3 := /*line :1106:49*/&(*_cgoIndex3)[3]; _cgoIndex4 := &/*line :1106:57*/a; _cgo4 := /*line :1106:56*/&(*_cgoIndex4)[4]; _cgoIndex5 := &/*line :1106:64*/a; _cgo5 := /*line :1106:63*/&(*_cgoIndex5)[5]; _cgoIndex6 := &/*line :1106:71*/a; _cgo6 := /*line :1106:70*/&(*_cgoIndex6)[6]; _cgoIndex7 := &/*line :1106:78*/a; _cgo7 := /*line :1106:77*/&(*_cgoIndex7)[7]; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo6, *_cgoIndex6); _cgoCheckPointer(_cgo7, *_cgoIndex7); _Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-slice", func(b *testing.B) {
		a := make([] /*line :1110:15*/_Ctype_VkDeviceCreateInfo /*line :1110:35*/, 8)
		for i := 0; i < b.N; i++ {
			func() { _cgoIndex0 := &/*line :1112:29*/a; _cgo0 := /*line :1112:28*/&(*_cgoIndex0)[0]; _cgoIndex1 := &/*line :1112:36*/a; _cgo1 := /*line :1112:35*/&(*_cgoIndex1)[1]; _cgoIndex2 := &/*line :1112:43*/a; _cgo2 := /*line :1112:42*/&(*_cgoIndex2)[2]; _cgoIndex3 := &/*line :1112:50*/a; _cgo3 := /*line :1112:49*/&(*_cgoIndex3)[3]; _cgoIndex4 := &/*line :1112:57*/a; _cgo4 := /*line :1112:56*/&(*_cgoIndex4)[4]; _cgoIndex5 := &/*line :1112:64*/a; _cgo5 := /*line :1112:63*/&(*_cgoIndex5)[5]; _cgoIndex6 := &/*line :1112:71*/a; _cgo6 := /*line :1112:70*/&(*_cgoIndex6)[6]; _cgoIndex7 := &/*line :1112:78*/a; _cgo7 := /*line :1112:77*/&(*_cgoIndex7)[7]; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo6, *_cgoIndex6); _cgoCheckPointer(_cgo7, *_cgoIndex7); _Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
}

// Benchmark measuring overhead from Go to C and back to Go (via a callback)
func benchCallback(b *testing.B) {
	var x = false
	for i := 0; i < b.N; i++ {
		nestedCall(func() { x = true })
	}
	if !x {
		b.Fatal("nestedCall was not invoked")
	}
}

var sinkString string

func benchGoString(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sinkString = ( /*line :1132:16*/_Cfunc_GoString /*line :1132:25*/)(( /*line :1132:27*/*_Cvar_cstr /*line :1132:32*/))
	}
	const want = "abcefghijklmnopqrstuvwxyzABCEFGHIJKLMNOPQRSTUVWXYZ1234567890"
	if sinkString != want {
		b.Fatalf("%q != %q", sinkString, want)
	}
}

// Static (build-time) test that syntax traversal visits all operands of s[i:j:k].
func sliceOperands(array [2000]int) {
	_ = array[( /*line :1142:12*/_Ciconst_KILO /*line :1142:17*/):( /*line :1142:19*/_Ciconst_KILO /*line :1142:24*/):( /*line :1142:26*/_Ciconst_KILO /*line :1142:31*/)] // no type error
}

// set in cgo_thread_lock.go init
var testThreadLockFunc = func(*testing.T) {}

// complex alignment

func TestComplexAlign(t *testing.T) {
	if ( /*line :1151:5*/*_Cvar_cplxAlign /*line :1151:15*/).x != 3.14 {
		t.Errorf("got %v, expected 3.14", ( /*line :1152:37*/*_Cvar_cplxAlign /*line :1152:47*/).x)
	}
	if ( /*line :1154:5*/*_Cvar_cplxAlign /*line :1154:15*/).y != 2.17 {
		t.Errorf("got %v, expected 2.17", ( /*line :1155:37*/*_Cvar_cplxAlign /*line :1155:47*/).y)
	}
}

// constants and pointer checking

func testCheckConst(t *testing.T) {
	// The test is that this compiles successfully.
	p := ( /*line :1163:7*/_Cfunc__CMalloc /*line :1163:14*/)( /*line :1163:16*/_Ctype_size_t /*line :1163:24*/(unsafe.Sizeof( /*line :1163:39*/_Ctype_int /*line :1163:44*/(0))))
	defer func() func() { _cgo0 := /*line :1164:15*/p; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	func() { _cgoBase0 := /*line :1165:19*/&_Ctype_CheckConstStruct{(*_Ctype_int)(p)}; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :1165:53*/_Ciconst_CheckConstVal; _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_CheckConstFunc(_cgo0, _cgo1); }()
}

// duplicate symbol

func duplicateSymbols() {
	fmt.Printf("%v %v %v\n", ( /*line :1171:27*/*_Cvar_base_symbol /*line :1171:39*/), ( /*line :1171:42*/_Cmacro_alias_one() /*line :1171:52*/), ( /*line :1171:55*/_Cmacro_alias_two() /*line :1171:65*/))
}

// environment

// This is really an os package test but here for convenience.
func testSetEnv(t *testing.T) {
	if runtime.GOOS == "windows" {
		// Go uses SetEnvironmentVariable on windows. However,
		// C runtime takes a *copy* at process startup of the
		// OS environment, and stores it in environ/envp.
		// It is this copy that	getenv/putenv manipulate.
		t.Logf("skipping test")
		return
	}
	const key = "CGO_OS_TEST_KEY"
	const val = "CGO_OS_TEST_VALUE"
	os.Setenv(key, val)
	keyc := ( /*line :1189:10*/_Cfunc_CString /*line :1189:18*/)(key)
	defer func() func() { _cgo0 := /*line :1190:15*/unsafe.Pointer(keyc); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	v := ( /*line :1191:7*/_Cfunc_getenv /*line :1191:14*/)(keyc)
	if uintptr(unsafe.Pointer(v)) == 0 {
		t.Fatal("getenv returned NULL")
	}
	vs := ( /*line :1195:8*/_Cfunc_GoString /*line :1195:17*/)(v)
	if vs != val {
		t.Fatalf("getenv() = %q; want %q", vs, val)
	}
}

// function pointer variables

func callBridge(f  /*line :1203:19*/_Ctype_intFunc /*line :1203:28*/) int {
	return int(( /*line :1204:13*/_Cfunc_bridge_int_func /*line :1204:29*/)(f))
}

func callCBridge(f  /*line :1207:20*/_Ctype_intFunc /*line :1207:29*/)  /*line :1207:31*/_Ctype_int /*line :1207:36*/ {
	return ( /*line :1208:9*/_Cfunc_bridge_int_func /*line :1208:25*/)(f)
}

func testFpVar(t *testing.T) {
	const expected = 42
	f :=  /*line :1213:7*/_Ctype_intFunc /*line :1213:16*/(( /*line :1213:17*/_Cgo_ptr(_Cfpvar_fp_fortytwo) /*line :1213:26*/))
	res1 := ( /*line :1214:10*/_Cfunc_bridge_int_func /*line :1214:26*/)(f)
	if r1 := int(res1); r1 != expected {
		t.Errorf("got %d, want %d", r1, expected)
	}
	res2 := callCBridge(f)
	if r2 := int(res2); r2 != expected {
		t.Errorf("got %d, want %d", r2, expected)
	}
	r3 := callBridge(f)
	if r3 != expected {
		t.Errorf("got %d, want %d", r3, expected)
	}
}

// issue 1222
type AsyncEvent struct {
	event  /*line :1230:8*/_Ctype_struct_ibv_async_event /*line :1230:32*/
}

// issue 1635

func test1635(t *testing.T) {
	( /*line :1236:2*/_Cfunc_scatter /*line :1236:10*/)()
	if v := ( /*line :1237:10*/*_Cvar_hola /*line :1237:15*/); v != 0 {
		t.Fatalf("C.hola is %d, should be 0", v)
	}
	if v := ( /*line :1240:10*/_Cfunc_testHola /*line :1240:19*/)(); v != 0 {
		t.Fatalf("C.testHola() is %d, should be 0", v)
	}
}

// issue 2470

func testUnsignedInt(t *testing.T) {
	a := (int64)(( /*line :1248:15*/_Ciconst_UINT32VAL /*line :1248:25*/))
	b := (int64)(0xc008427b)
	if a != b {
		t.Errorf("Incorrect unsigned int - got %x, want %x", a, b)
	}
}

// issue 3250

func test3250(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("not applicable on windows")
	}

	t.Skip("skipped, see golang.org/issue/5885")
	var (
		thres = 1
		sig   = syscall_dot_SIGCHLD
	)
	type result struct {
		n   int
		sig os.Signal
	}
	var (
		sigCh     = make(chan os.Signal, 10)
		waitStart = make(chan struct{})
		waitDone  = make(chan result)
	)

	signal.Notify(sigCh, sig)

	go func() {
		n := 0
		alarm := time.After(time.Second * 3)
		for {
			select {
			case <-waitStart:
				waitStart = nil
			case v := <-sigCh:
				n++
				if v != sig || n > thres {
					waitDone <- result{n, v}
					return
				}
			case <-alarm:
				waitDone <- result{n, sig}
				return
			}
		}
	}()

	waitStart <- struct{}{}
	( /*line :1300:2*/_Cfunc_testSendSIG /*line :1300:14*/)()
	r := <-waitDone
	if r.sig != sig {
		t.Fatalf("received signal %v, but want %v", r.sig, sig)
	}
	t.Logf("got %d signals\n", r.n)
	if r.n <= thres {
		t.Fatalf("expected more than %d", thres)
	}
}

// issue 3261

func testLibgcc(t *testing.T) {
	var table = []struct {
		in, out  /*line :1315:11*/_Ctype_int /*line :1315:16*/
	}{
		{0, 0},
		{1, 1},
		{-42, 42},
		{1000300, 1000300},
		{1 - 1<<31, 1<<31 - 1},
	}
	for _, v := range table {
		if o := ( /*line :1324:11*/_Cfunc_vabs /*line :1324:16*/)(v.in); o != v.out {
			t.Fatalf("abs(%d) got %d, should be %d", v.in, o, v.out)
			return
		}
	}
}

// issue 3729

func test3729(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("skipping on windows")
	}

	_, e := ( /*line :1338:10*/_C2func_g /*line :1338:12*/)()
	if e != syscall.E2BIG {
		t.Errorf("got %q, expect %q", e, syscall.E2BIG)
	}
	_, e = ( /*line :1342:9*/_C2func_g2 /*line :1342:12*/)(( /*line :1342:14*/_Ciconst_EINVAL /*line :1342:21*/), ( /*line :1342:24*/_Cfconst__expA /*line :1342:30*/), ( /*line :1342:33*/_Cfconst__expB /*line :1342:39*/), ( /*line :1342:42*/*_Cvar__expC /*line :1342:48*/), ( /*line :1342:51*/*_Cvar__expD /*line :1342:57*/))
	if e != syscall.EINVAL {
		t.Errorf("got %q, expect %q", e, syscall.EINVAL)
	}
}

// issue 3945

func testPrintf(t *testing.T) {
	( /*line :1351:2*/_Cfunc_say /*line :1351:6*/)()
}

// issue 4054

var issue4054a = []int{( /*line :1356:24*/_Ciconst_A /*line :1356:26*/), ( /*line :1356:29*/_Ciconst_B /*line :1356:31*/), ( /*line :1356:34*/_Ciconst_C /*line :1356:36*/), ( /*line :1356:39*/_Ciconst_D /*line :1356:41*/), ( /*line :1356:44*/_Ciconst_E /*line :1356:46*/), ( /*line :1356:49*/_Ciconst_F /*line :1356:51*/), ( /*line :1356:54*/_Ciconst_G /*line :1356:56*/), ( /*line :1356:59*/_Ciconst_H /*line :1356:61*/), ( /*line :1356:64*/_Cfconst_I /*line :1356:66*/), ( /*line :1356:69*/_Ciconst_J /*line :1356:71*/)}

// issue 4339

func test4339(t *testing.T) {
	func() { _cgoBase0 := /*line :1361:15*/&*_Cvar_exported4339; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_handle4339(_cgo0); }()
}

// issue 4417

func testBoolAlign(t *testing.T) {
	b := ( /*line :1367:7*/_Cfunc_c_bool /*line :1367:14*/)(true, true, 10, true, false)
	if b != 10 {
		t.Fatalf("found %d expected 10\n", b)
	}
	b = ( /*line :1371:6*/_Cfunc_c_bool /*line :1371:13*/)(true, true, 5, true, true)
	if b != 5 {
		t.Fatalf("found %d expected 5\n", b)
	}
	b = ( /*line :1375:6*/_Cfunc_c_bool /*line :1375:13*/)(true, true, 3, true, false)
	if b != 3 {
		t.Fatalf("found %d expected 3\n", b)
	}
	b = ( /*line :1379:6*/_Cfunc_c_bool /*line :1379:13*/)(false, false, 1, true, false)
	if b != 1 {
		t.Fatalf("found %d expected 1\n", b)
	}
	b = ( /*line :1383:6*/_Cfunc_c_bool /*line :1383:13*/)(false, true, 200, true, false)
	if b != 200 {
		t.Fatalf("found %d expected 200\n", b)
	}
}

// issue 4857

func test4857() {
	_ = ( /*line :1392:6*/_Cfunc_issue4857 /*line :1392:16*/)()
}

// issue 5224

func testCflags(t *testing.T) {
	is_windows := ( /*line :1398:16*/*_Cvar_is_windows /*line :1398:27*/) == 1
	if is_windows != (runtime.GOOS == "windows") {
		t.Errorf("is_windows: %v, runtime.GOOS: %s", is_windows, runtime.GOOS)
	}
	if ( /*line :1402:5*/*_Cvar_common /*line :1402:12*/) != 123 {
		t.Errorf("common: %v (expected 123)", ( /*line :1403:41*/*_Cvar_common /*line :1403:48*/))
	}
}

// issue 5227

func test5227(t *testing.T) {
	( /*line :1410:2*/_Cfunc_init /*line :1410:7*/)()
}

func selectfont()  /*line :1413:19*/_Ctype_Fontinfo /*line :1413:29*/ {
	return ( /*line :1414:9*/*_Cvar_SansTypeface /*line :1414:22*/)
}

// issue 5242

func test5242(t *testing.T) {
	if got := ( /*line :1420:12*/_Cfunc_issue5242 /*line :1420:22*/)( /*line :1420:24*/_Ctype_foo /*line :1420:29*/{},  /*line :1420:33*/_Ctype_bar /*line :1420:38*/{}); got != 5242 {
		t.Errorf("got %v", got)
	}
}

func test5603(t *testing.T) {
	var x [5]int64
	exp := int64(( /*line :1427:15*/*_Cvar_issue5603exp /*line :1427:28*/))
	x[0] = int64(( /*line :1428:15*/_Cfunc_issue5603foo0 /*line :1428:29*/)())
	x[1] = int64(( /*line :1429:15*/_Cfunc_issue5603foo1 /*line :1429:29*/)(nil))
	x[2] = int64(( /*line :1430:15*/_Cfunc_issue5603foo2 /*line :1430:29*/)(nil, nil))
	x[3] = int64(( /*line :1431:15*/_Cfunc_issue5603foo3 /*line :1431:29*/)(nil, nil, nil))
	x[4] = int64(( /*line :1432:15*/_Cfunc_issue5603foo4 /*line :1432:29*/)(nil, nil, nil, nil))
	for i, v := range x {
		if v != exp {
			t.Errorf("issue5603foo%d() returns %v, expected %v", i, v, exp)
		}
	}
}

// issue 5337

func test5337(t *testing.T) {
	( /*line :1443:2*/_Cfunc_test5337 /*line :1443:11*/)()
}

// issue 5740

func test5740(t *testing.T) {
	if v := ( /*line :1449:10*/_Cfunc_test5740a /*line :1449:20*/)() + ( /*line :1449:26*/_Cfunc_test5740b /*line :1449:36*/)(); v != 5 {
		t.Errorf("expected 5, got %v", v)
	}
}

// issue 5986

func test5986(t *testing.T) {
	( /*line :1457:2*/_Cfunc_output5986 /*line :1457:13*/)()
}

// issue 6128

func test6128() {
	// nothing to run, just make sure this compiles.
	_ = ( /*line :1464:6*/_Ciconst_X /*line :1464:8*/)
}

// issue 6390

func test6390(t *testing.T) {
	p1 := ( /*line :1470:8*/_Cfunc__CMalloc /*line :1470:15*/)(1024)
	if p1 == nil {
		t.Fatalf("C.malloc(1024) returned nil")
	}
	p2 := ( /*line :1474:8*/_Cfunc__CMalloc /*line :1474:15*/)(0)
	if p2 == nil {
		t.Fatalf("C.malloc(0) returned nil")
	}
	func() { _cgo0 := /*line :1478:9*/p1; _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :1479:9*/p2; _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
}

func test6472() {
	// nothing to run, just make sure this compiles
	s := new( /*line :1484:11*/_Ctype_z /*line :1484:14*/)
	println(s.y[0].x)
}

// issue 6506

func test6506() {
	// nothing to run, just make sure this compiles
	var x  /*line :1492:8*/_Ctype_size_t /*line :1492:16*/

	( /*line :1494:2*/_Cfunc_calloc /*line :1494:9*/)(x, x)
	( /*line :1495:2*/_Cfunc__CMalloc /*line :1495:9*/)(x)
	( /*line :1496:2*/_Cfunc_realloc /*line :1496:10*/)(nil, x)
	( /*line :1497:2*/_Cfunc_memcpy /*line :1497:9*/)(nil, nil, x)
	( /*line :1498:2*/_Cfunc_memcmp /*line :1498:9*/)(nil, nil, x)
	( /*line :1499:2*/_Cfunc_memmove /*line :1499:10*/)(nil, nil, x)
	( /*line :1500:2*/_Cfunc_strncpy /*line :1500:10*/)(nil, nil, x)
	( /*line :1501:2*/_Cfunc_strncmp /*line :1501:10*/)(nil, nil, x)
	( /*line :1502:2*/_Cfunc_strncat /*line :1502:10*/)(nil, nil, x)
	x = ( /*line :1503:6*/_Cfunc_strxfrm /*line :1503:14*/)(nil, nil, x)
	( /*line :1504:2*/_Cfunc_memchr /*line :1504:9*/)(nil, 0, x)
	x = ( /*line :1505:6*/_Cfunc_strcspn /*line :1505:14*/)(nil, nil)
	x = ( /*line :1506:6*/_Cfunc_strspn /*line :1506:13*/)(nil, nil)
	( /*line :1507:2*/_Cfunc_memset /*line :1507:9*/)(nil, 0, x)
	x = ( /*line :1508:6*/_Cfunc_strlen /*line :1508:13*/)(nil)
	_ = x
}

// issue 6612

func testNaming(t *testing.T) {
	( /*line :1515:2*/_Cfunc_myfunc /*line :1515:9*/)()
	( /*line :1516:2*/_Cfunc_myfunc_def /*line :1516:13*/)()
	if v := ( /*line :1517:10*/*_Cvar_myvar /*line :1517:16*/); v != 5 {
		t.Errorf("C.myvar = %d, want 5", v)
	}
	if v := ( /*line :1520:10*/_Cmacro_myvar_def() /*line :1520:20*/); v != 5 {
		t.Errorf("C.myvar_def = %d, want 5", v)
	}
	if s := ( /*line :1523:10*/_Cfunc_GoString /*line :1523:19*/)(( /*line :1523:21*/*_Cvar_mytext /*line :1523:28*/)); s != "abcdef" {
		t.Errorf("C.mytext = %q, want %q", s, "abcdef")
	}
	if s := ( /*line :1526:10*/_Cfunc_GoString /*line :1526:19*/)(( /*line :1526:21*/_Cmacro_mytext_def() /*line :1526:32*/)); s != "abcdef" {
		t.Errorf("C.mytext_def = %q, want %q", s, "abcdef")
	}
	if c := ( /*line :1529:10*/_Ciconst_myenum /*line :1529:17*/); c != 1234 {
		t.Errorf("C.myenum = %v, want 1234", c)
	}
	if c := ( /*line :1532:10*/_Ciconst_myenum_def /*line :1532:21*/); c != 1234 {
		t.Errorf("C.myenum_def = %v, want 1234", c)
	}
	{
		const c = ( /*line :1536:13*/_Ciconst_myenum /*line :1536:20*/)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	{
		const c = ( /*line :1542:13*/_Ciconst_myenum_def /*line :1542:24*/)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	if c := ( /*line :1547:10*/_Ciconst_myint_def /*line :1547:20*/); c != 12345 {
		t.Errorf("C.myint_def = %v, want 12345", c)
	}
	{
		const c = ( /*line :1551:13*/_Ciconst_myint_def /*line :1551:23*/)
		if c != 12345 {
			t.Errorf("C.myint as const = %v, want 12345", c)
		}
	}

	if c := ( /*line :1557:10*/_Cfconst_myfloat_def /*line :1557:22*/); c != 1.5 {
		t.Errorf("C.myint_def = %v, want 1.5", c)
	}
	{
		const c = ( /*line :1561:13*/_Cfconst_myfloat_def /*line :1561:25*/)
		if c != 1.5 {
			t.Errorf("C.myint as const = %v, want 1.5", c)
		}
	}

	if s := ( /*line :1567:10*/_Csconst_mystring_def /*line :1567:23*/); s != "hello" {
		t.Errorf("C.mystring_def = %q, want %q", s, "hello")
	}
}

// issue 6907

func test6907(t *testing.T) {
	want := "yarn"
	if got := ( /*line :1576:12*/_Cfunc_GoString /*line :1576:21*/)(( /*line :1576:23*/_Cfunc_Issue6907CopyString /*line :1576:43*/)(want)); got != want {
		t.Errorf("C.GoString(C.Issue6907CopyString(%q)) == %q, want %q", want, got, want)
	}
}

// issue 7560

func test7560(t *testing.T) {
	// some mingw don't implement __packed__ correctly.
	if ( /*line :1585:5*/_Cfunc_offset7560 /*line :1585:16*/)() != 1 {
		t.Skip("C compiler did not pack struct")
	}

	// C.misaligned should have x but then a padding field to get to the end of the struct.
	// There should not be a field named 'y'.
	var v  /*line :1591:8*/_Ctype_misaligned /*line :1591:20*/
	rt := reflect.TypeOf(&v).Elem()
	if rt.NumField() != 2 || rt.Field(0).Name != "x" || rt.Field(1).Name != "_" {
		t.Errorf("unexpected fields in C.misaligned:\n")
		for i := 0; i < rt.NumField(); i++ {
			t.Logf("%+v\n", rt.Field(i))
		}
	}
}

// issue 7786

func f() {
	var x1 * /*line :1604:10*/_Ctype_typedef_test7786 /*line :1604:28*/
	var x2 * /*line :1605:10*/_Ctype_struct_test7786 /*line :1605:27*/
	x1 = x2
	x2 = x1
	func() { _cgo0 := /*line :1608:10*/x1; _cgoCheckPointer(_cgo0, nil); _Cfunc_f7786(_cgo0); }()
	func() { _cgo0 := /*line :1609:10*/x2; _cgoCheckPointer(_cgo0, nil); _Cfunc_f7786(_cgo0); }()
	func() { _cgo0 := /*line :1610:10*/x1; _cgoCheckPointer(_cgo0, nil); _Cfunc_g7786(_cgo0); }()
	func() { _cgo0 := /*line :1611:10*/x2; _cgoCheckPointer(_cgo0, nil); _Cfunc_g7786(_cgo0); }()

	var b1 * /*line :1613:10*/_Ctype_typedef_body7786 /*line :1613:28*/
	var b2 * /*line :1614:10*/_Ctype_struct_body7786 /*line :1614:27*/
	b1 = b2
	b2 = b1
	( /*line :1617:2*/_Cfunc_b7786 /*line :1617:8*/)(b1)
	( /*line :1618:2*/_Cfunc_b7786 /*line :1618:8*/)(b2)
	( /*line :1619:2*/_Cfunc_c7786 /*line :1619:8*/)(b1)
	( /*line :1620:2*/_Cfunc_c7786 /*line :1620:8*/)(b2)

	var u1 * /*line :1622:10*/_Ctype_typedef_union7786 /*line :1622:29*/
	var u2 * /*line :1623:10*/_Ctype_union_union7786 /*line :1623:27*/
	u1 = u2
	u2 = u1
	func() { _cgo0 := /*line :1626:10*/u1; _cgoCheckPointer(_cgo0, nil); _Cfunc_u7786(_cgo0); }()
	func() { _cgo0 := /*line :1627:10*/u2; _cgoCheckPointer(_cgo0, nil); _Cfunc_u7786(_cgo0); }()
	func() { _cgo0 := /*line :1628:10*/u1; _cgoCheckPointer(_cgo0, nil); _Cfunc_v7786(_cgo0); }()
	func() { _cgo0 := /*line :1629:10*/u2; _cgoCheckPointer(_cgo0, nil); _Cfunc_v7786(_cgo0); }()
}

// issue 8092

func test8092(t *testing.T) {
	tests := []struct {
		s    string
		a, b * /*line :1637:9*/_Ctype_char /*line :1637:15*/
	}{
		{"text", &( /*line :1639:13*/*_Cvar_text /*line :1639:18*/)[0], ( /*line :1639:24*/_Cfunc_ctext /*line :1639:30*/)()},
		{"data", &( /*line :1640:13*/*_Cvar_data /*line :1640:18*/)[0], ( /*line :1640:24*/_Cfunc_cdata /*line :1640:30*/)()},
	}
	for _, test := range tests {
		if test.a != test.b {
			t.Errorf("%s: pointer mismatch: %v != %v", test.s, test.a, test.b)
		}
		if got := ( /*line :1646:13*/_Cfunc_GoString /*line :1646:22*/)(test.a); got != test.s {
			t.Errorf("%s: points at %#v, want %#v", test.s, got, test.s)
		}
	}
}

// issues 8368 and 8441

func issue8368(one * /*line :1654:21*/_Ctype_struct_one /*line :1654:33*/, two * /*line :1654:40*/_Ctype_struct_two /*line :1654:52*/) {
}

func issue8441(one * /*line :1657:21*/_Ctype_one /*line :1657:26*/, two * /*line :1657:33*/_Ctype_two /*line :1657:38*/) {
	issue8441(two.x, one.x)
}

// issue 8428

var _ =  /*line :1663:9*/_Ctype_struct_issue8428one /*line :1663:30*/{
	b:  /*line :1664:5*/_Ctype_char /*line :1664:11*/(0),
	// The trailing rest field is not available in cgo.
	// See issue 11925.
	// rest: [0]C.char{},
}

var _ =  /*line :1670:9*/_Ctype_struct_issue8428two /*line :1670:30*/{
	p:    unsafe.Pointer(nil),
	b:     /*line :1672:8*/_Ctype_char /*line :1672:14*/(0),
	rest: [0] /*line :1673:11*/_Ctype_char /*line :1673:17*/{},
}

var _ =  /*line :1676:9*/_Ctype_struct_issue8428three /*line :1676:32*/{
	w: [1][2][3][0] /*line :1677:17*/_Ctype_char /*line :1677:23*/{},
	x: [2][3][0][1] /*line :1678:17*/_Ctype_char /*line :1678:23*/{},
	y: [3][0][1][2] /*line :1679:17*/_Ctype_char /*line :1679:23*/{},
	z: [0][1][2][3] /*line :1680:17*/_Ctype_char /*line :1680:23*/{},
}

// issue 8811

func test8811(t *testing.T) {
	( /*line :1686:2*/_Cfunc_issue8811Execute /*line :1686:19*/)()
}

// issue 9557

func test9557(t *testing.T) {
	// implicitly dereference a Go variable
	foo := ( /*line :1693:9*/*_Cvar_issue9557foo /*line :1693:22*/)
	if v := foo.a; v != 42 {
		t.Fatalf("foo.a expected 42, but got %d", v)
	}

	// explicitly dereference a C variable
	if v := (*( /*line :1699:12*/*_Cvar_issue9557foo /*line :1699:25*/)).a; v != 42 {
		t.Fatalf("(*C.issue9557foo).a expected 42, but is %d", v)
	}

	// implicitly dereference a C variable
	if v := ( /*line :1704:10*/*_Cvar_issue9557foo /*line :1704:23*/).a; v != 42 {
		t.Fatalf("C.issue9557foo.a expected 42, but is %d", v)
	}
}

// issue 8331 part 1

func issue8331a()  /*line :1711:19*/_Ctype_issue8331 /*line :1711:30*/ {
	return issue8331Var
}

// issue 10303

func test10303(t *testing.T, n int) {
	if runtime.Compiler == "gccgo" {
		t.Skip("gccgo permits C pointers on the stack")
	}

	// Run at a few different stack depths just to avoid an unlucky pass
	// due to variables ending up on different pages.
	if n > 0 {
		test10303(t, n-1)
	}
	if t.Failed() {
		return
	}
	var x, y, z, v, si  /*line :1730:21*/_Ctype_int /*line :1730:26*/
	var s  /*line :1731:8*/_Ctype_Struct /*line :1731:16*/
	( /*line :1732:2*/_Cfunc_setintstar /*line :1732:13*/)(&x)
	( /*line :1733:2*/_Cfunc_setintptr /*line :1733:12*/)(&y)
	func() { _cgoBase0 := /*line :1734:30*/&v; _cgo0 := /*line :1734:15*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_setvoidptr(_cgo0); }()
	s.P = &si
	( /*line :1736:2*/_Cfunc_setstruct /*line :1736:12*/)(s)

	if uintptr(unsafe.Pointer(&x))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C int* argument on stack")
	}
	if uintptr(unsafe.Pointer(&y))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C intptr argument on stack")
	}
	if uintptr(unsafe.Pointer(&v))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C void* argument on stack")
	}
	if uintptr(unsafe.Pointer(&si))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C struct field pointer on stack")
	}
}

// issue 11925

func test11925(t *testing.T) {
	if ( /*line :1755:5*/_Ciconst_sizeof_struct_a11925 /*line :1755:26*/) != unsafe.Sizeof( /*line :1755:45*/_Ctype_struct_a11925 /*line :1755:60*/{}) {
		t.Errorf("size of a changed: C %d, Go %d", ( /*line :1756:46*/_Ciconst_sizeof_struct_a11925 /*line :1756:67*/), unsafe.Sizeof( /*line :1756:84*/_Ctype_struct_a11925 /*line :1756:99*/{}))
	}
	if ( /*line :1758:5*/_Ciconst_sizeof_struct_b11925 /*line :1758:26*/) != unsafe.Sizeof( /*line :1758:45*/_Ctype_struct_b11925 /*line :1758:60*/{}) {
		t.Errorf("size of b changed: C %d, Go %d", ( /*line :1759:46*/_Ciconst_sizeof_struct_b11925 /*line :1759:67*/), unsafe.Sizeof( /*line :1759:84*/_Ctype_struct_b11925 /*line :1759:99*/{}))
	}
}

// issue 12030

func test12030(t *testing.T) {
	buf := (* /*line :1766:11*/_Ctype_char /*line :1766:17*/)(( /*line :1766:19*/_Cfunc__CMalloc /*line :1766:26*/)(256))
	defer func() func() { _cgo0 := /*line :1767:15*/unsafe.Pointer(buf); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	for _, f := range []float64{1.0, 2.0, 3.14} {
		( /*line :1769:3*/_Cfunc_issue12030conv /*line :1769:18*/)(buf,  /*line :1769:25*/_Ctype_double /*line :1769:33*/(f))
		got := ( /*line :1770:10*/_Cfunc_GoString /*line :1770:19*/)(buf)
		if want := fmt.Sprintf("d=%g", f); got != want {
			t.Fatalf("C.sprintf failed for %g: %q != %q", f, got, want)
		}
	}
}

// issue 13402

var _  /*line :1779:7*/_Ctype_complexfloat /*line :1779:21*/
var _  /*line :1780:7*/_Ctype_complexdouble /*line :1780:22*/

// issue 13930
// Test that cgo's multiple-value special form for
// C function calls works in variable declaration statements.

var _, _ = ( /*line :1786:12*/_C2func_abs /*line :1786:16*/)(0)

// issue 14838

func test14838(t *testing.T) {
	data := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	cData := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :1792:20*/data; _cgoCheckPointer(_cgo0, nil); return _Cfunc_CBytes(_cgo0); }()
	defer func() func() { _cgo0 := /*line :1793:15*/cData; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()

	if ( /*line :1795:5*/_Cfunc_check_cbytes /*line :1795:18*/)((* /*line :1795:22*/_Ctype_char /*line :1795:28*/)(cData),  /*line :1795:38*/_Ctype_size_t /*line :1795:46*/(len(data))) == 0 {
		t.Fatalf("mismatched data: expected %v, got %v", data, (*(*[10]byte)(unsafe.Pointer(cData)))[:])
	}
}

// issue 17065

var sink  /*line :1802:10*/_Ctype_int /*line :1802:15*/

func test17065(t *testing.T) {
	if runtime.GOOS == "darwin" || runtime.GOOS == "ios" {
		t.Skip("broken on darwin; issue 17065")
	}
	for i := range ( /*line :1808:17*/*_Cvar_ii /*line :1808:20*/) {
		sink = ( /*line :1809:10*/*_Cvar_ii /*line :1809:13*/)[i]
	}
}

// issue 17537

func test17537(t *testing.T) {
	v :=  /*line :1816:7*/_Ctype_S17537 /*line :1816:15*/{i: 17537}
	if got, want := ( /*line :1817:18*/_Cfunc_I17537 /*line :1817:25*/)(&v),  /*line :1817:32*/_Ctype_int /*line :1817:37*/(17537); got != want {
		t.Errorf("got %d, want %d", got, want)
	}

	p := (* /*line :1821:9*/_Ctype_char /*line :1821:15*/)(( /*line :1821:17*/_Cfunc__CMalloc /*line :1821:24*/)(1))
	*p = 17
	if got, want := func() _Ctype_int{ _cgoBase0 := /*line :1823:27*/&p; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return _Cfunc_F17537(_cgo0); }(),  /*line :1823:32*/_Ctype_int /*line :1823:37*/(17); got != want {
		t.Errorf("got %d, want %d", got, want)
	}

	( /*line :1827:2*/_Cfunc_F18298 /*line :1827:9*/)(nil)
	var v18298  /*line :1828:13*/_Ctype_T18298_2 /*line :1828:23*/
	func() { _cgo0 := _Ctype_T18298_1(v18298); _cgoCheckPointer(_cgo0, nil); _Cfunc_G18298(_cgo0); }()
}

// issue 17723

func testAPI() {
	var cs * /*line :1835:10*/_Ctype_char /*line :1835:16*/
	cs = ( /*line :1836:7*/_Cfunc_CString /*line :1836:15*/)("hello")
	defer func() func() { _cgo0 := /*line :1837:15*/unsafe.Pointer(cs); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	var s string
	s = ( /*line :1839:6*/_Cfunc_GoString /*line :1839:15*/)((* /*line :1839:19*/_Ctype_char /*line :1839:25*/)(( /*line :1839:27*/*_Cvar_api_hello /*line :1839:37*/)))
	s = ( /*line :1840:6*/_Cfunc_GoStringN /*line :1840:16*/)((* /*line :1840:20*/_Ctype_char /*line :1840:26*/)(( /*line :1840:28*/*_Cvar_api_hello /*line :1840:38*/)),  /*line :1840:42*/_Ctype_int /*line :1840:47*/(6))
	var b []byte
	b = func() []byte{ _cgo0 := /*line :1842:16*/unsafe.Pointer(*_Cvar_api_hello); var _cgo1 _Ctype_int = _Ctype_int(6); _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()
	_, _ = s, b
	( /*line :1844:2*/_Cfunc_cstring_pointer_fun /*line :1844:22*/)(nil)
}

// issue 18126

func test18126(t *testing.T) {
	p := ( /*line :1850:7*/_Cfunc__CMalloc /*line :1850:14*/)(1)
	_, err := func() (_Ctype_void, error){ _cgoBase0 := /*line :1851:26*/&p; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return _C2func_Issue18126C(_cgo0); }()
	func() { _cgo0 := /*line :1852:9*/p; _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	_ = err
}

// issue 18720

func test18720(t *testing.T) {
	if got, want := ( /*line :1859:18*/_Csconst_HELLO_WORLD /*line :1859:30*/), "hello\000world"; got != want {
		t.Errorf("C.HELLO_WORLD == %q, expected %q", got, want)
	}

	if got, want := ( /*line :1863:18*/_Cmacro_VAR1() /*line :1863:23*/),  /*line :1863:26*/_Ctype_int /*line :1863:31*/(5); got != want {
		t.Errorf("C.VAR1 == %v, expected %v", got, want)
	}

	if got, want := *( /*line :1867:19*/_Cmacro_ADDR() /*line :1867:24*/),  /*line :1867:27*/_Ctype_int /*line :1867:32*/(5); got != want {
		t.Errorf("*C.ADDR == %v, expected %v", got, want)
	}

	if got, want := ( /*line :1871:18*/_Cmacro_CALL() /*line :1871:23*/),  /*line :1871:26*/_Ctype_int /*line :1871:31*/(6); got != want {
		t.Errorf("C.CALL == %v, expected %v", got, want)
	}

	if got, want := ( /*line :1875:18*/_Cmacro_CALL() /*line :1875:23*/),  /*line :1875:26*/_Ctype_int /*line :1875:31*/(7); got != want {
		t.Errorf("C.CALL == %v, expected %v", got, want)
	}

	// Issue 20125.
	if got, want := ( /*line :1880:18*/_Ciconst_SIZE_OF_FOO /*line :1880:30*/), 1; got != want {
		t.Errorf("C.SIZE_OF_FOO == %v, expected %v", got, want)
	}
}

// issue 20129

func test20129(t *testing.T) {
	if ( /*line :1888:5*/*_Cvar_issue20129 /*line :1888:16*/) != 0 {
		t.Fatal("test is broken")
	}
	( /*line :1891:2*/_Cfunc_issue20129Foo /*line :1891:16*/)()
	if ( /*line :1892:5*/*_Cvar_issue20129 /*line :1892:16*/) != 1 {
		t.Errorf("got %v but expected %v", ( /*line :1893:38*/*_Cvar_issue20129 /*line :1893:49*/), 1)
	}
	( /*line :1895:2*/_Cfunc_issue20129Bar /*line :1895:16*/)()
	if ( /*line :1896:5*/*_Cvar_issue20129 /*line :1896:16*/) != 2 {
		t.Errorf("got %v but expected %v", ( /*line :1897:38*/*_Cvar_issue20129 /*line :1897:49*/), 2)
	}
}

// issue 20369

func test20369(t *testing.T) {
	if ( /*line :1904:5*/_Ciconst_XUINT64_MAX /*line :1904:17*/) != math.MaxUint64 {
		t.Fatalf("got %v, want %v", uint64(( /*line :1905:38*/_Ciconst_XUINT64_MAX /*line :1905:50*/)), uint64(math.MaxUint64))
	}
}

// issue 21668

var issue21668_X = ( /*line :1911:20*/*_Cvar_x21668 /*line :1911:27*/)

// issue 21708

func test21708(t *testing.T) {
	if got, want := ( /*line :1916:18*/_Ciconst_CAST_TO_INT64 /*line :1916:32*/), -1; got != want {
		t.Errorf("C.CAST_TO_INT64 == %v, expected %v", got, want)
	}
}

// issue 21809

func test21809(t *testing.T) {
	longVar :=  /*line :1924:13*/_Ctype_long /*line :1924:19*/(3)
	typedefVar :=  /*line :1925:16*/_Ctype_MySigned_t /*line :1925:28*/(4)
	typedefTypedefVar :=  /*line :1926:23*/_Ctype_MySigned2_t /*line :1926:36*/(5)

	// all three should be considered identical to `long`
	if ret := ( /*line :1929:12*/_Cfunc_takes_long /*line :1929:23*/)(longVar); ret != 9 {
		t.Errorf("got %v but expected %v", ret, 9)
	}
	if ret := ( /*line :1932:12*/_Cfunc_takes_long /*line :1932:23*/)(typedefVar); ret != 16 {
		t.Errorf("got %v but expected %v", ret, 16)
	}
	if ret := ( /*line :1935:12*/_Cfunc_takes_long /*line :1935:23*/)(typedefTypedefVar); ret != 25 {
		t.Errorf("got %v but expected %v", ret, 25)
	}

	// They should also be identical to the typedef'd type
	if ret := ( /*line :1940:12*/_Cfunc_takes_typedef /*line :1940:26*/)(longVar); ret != 9 {
		t.Errorf("got %v but expected %v", ret, 9)
	}
	if ret := ( /*line :1943:12*/_Cfunc_takes_typedef /*line :1943:26*/)(typedefVar); ret != 16 {
		t.Errorf("got %v but expected %v", ret, 16)
	}
	if ret := ( /*line :1946:12*/_Cfunc_takes_typedef /*line :1946:26*/)(typedefTypedefVar); ret != 25 {
		t.Errorf("got %v but expected %v", ret, 25)
	}
}

// issue 22906

func test22906(t *testing.T) {
	var x1  /*line :1954:9*/_Ctype_jobject /*line :1954:18*/ = 0 // Note: 0, not nil. That makes sure we use uintptr for these types.
	_ = x1
	var x2  /*line :1956:9*/_Ctype_jclass /*line :1956:17*/ = 0
	_ = x2
	var x3  /*line :1958:9*/_Ctype_jthrowable /*line :1958:21*/ = 0
	_ = x3
	var x4  /*line :1960:9*/_Ctype_jstring /*line :1960:18*/ = 0
	_ = x4
	var x5  /*line :1962:9*/_Ctype_jarray /*line :1962:17*/ = 0
	_ = x5
	var x6  /*line :1964:9*/_Ctype_jbooleanArray /*line :1964:24*/ = 0
	_ = x6
	var x7  /*line :1966:9*/_Ctype_jbyteArray /*line :1966:21*/ = 0
	_ = x7
	var x8  /*line :1968:9*/_Ctype_jcharArray /*line :1968:21*/ = 0
	_ = x8
	var x9  /*line :1970:9*/_Ctype_jshortArray /*line :1970:22*/ = 0
	_ = x9
	var x10  /*line :1972:10*/_Ctype_jintArray /*line :1972:21*/ = 0
	_ = x10
	var x11  /*line :1974:10*/_Ctype_jlongArray /*line :1974:22*/ = 0
	_ = x11
	var x12  /*line :1976:10*/_Ctype_jfloatArray /*line :1976:23*/ = 0
	_ = x12
	var x13  /*line :1978:10*/_Ctype_jdoubleArray /*line :1978:24*/ = 0
	_ = x13
	var x14  /*line :1980:10*/_Ctype_jobjectArray /*line :1980:24*/ = 0
	_ = x14
	var x15  /*line :1982:10*/_Ctype_jweak /*line :1982:17*/ = 0
	_ = x15
}

// issue 22958
// Nothing to run, just make sure this compiles.
var Vissue22958  /*line :1988:17*/_Ctype_issue22958Type /*line :1988:33*/

func test23356(t *testing.T) {
	if got, want := ( /*line :1991:18*/_Cfunc_a /*line :1991:20*/)(),  /*line :1991:25*/_Ctype_int /*line :1991:30*/(5); got != want {
		t.Errorf("C.a() == %v, expected %v", got, want)
	}
	if got, want := ( /*line :1994:18*/_Cfunc_r /*line :1994:20*/)(),  /*line :1994:25*/_Ctype_int /*line :1994:30*/(3); got != want {
		t.Errorf("C.r() == %v, expected %v", got, want)
	}
}

// issue 23720

func Issue23720F() {
	var x  /*line :2002:8*/_Ctype_issue23720A /*line :2002:21*/
	( /*line :2003:2*/_Cfunc_issue23720F /*line :2003:14*/)(x)
}

// issue 24206

func test24206(t *testing.T) {
	if runtime.GOOS != "linux" || runtime.GOARCH != "amd64" {
		t.Skipf("skipping on %s/%s", runtime.GOOS, runtime.GOARCH)
	}

	if l := len(( /*line :2013:14*/_Cfunc_GoString /*line :2013:23*/)(( /*line :2013:25*/_Cfunc_dangerousString1 /*line :2013:42*/)())); l != 123 {
		t.Errorf("Incorrect string length - got %d, want 123", l)
	}
	if l := len(( /*line :2016:14*/_Cfunc_GoString /*line :2016:23*/)(( /*line :2016:25*/_Cfunc_dangerousString2 /*line :2016:42*/)())); l != 4096+123 {
		t.Errorf("Incorrect string length - got %d, want %d", l, 4096+123)
	}
}

// issue 25143

func issue25143sum(ns ... /*line :2023:26*/_Ctype_int /*line :2023:31*/)  /*line :2023:33*/_Ctype_int /*line :2023:38*/ {
	total :=  /*line :2024:11*/_Ctype_int /*line :2024:16*/(0)
	for _, n := range ns {
		total += n
	}
	return total
}

func test25143(t *testing.T) {
	if got, want := issue25143sum(1, 2, 3),  /*line :2032:42*/_Ctype_int /*line :2032:47*/(6); got != want {
		t.Errorf("issue25143sum(1, 2, 3) == %v, expected %v", got, want)
	}
}

// issue 26066
// Wrong type of constant with GCC 8 and newer.

func test26066(t *testing.T) {
	var i = int64(( /*line :2041:16*/*_Cvar_issue26066 /*line :2041:27*/))
	if i != -1 {
		t.Errorf("got %d, want -1", i)
	}
}

// issue 26517
var a  /*line :2048:7*/_Ctype_TypeOne /*line :2048:16*/
var b  /*line :2049:7*/_Ctype_TypeTwo /*line :2049:16*/

// issue 27660
// Stress the interaction between the race detector and cgo in an
// attempt to reproduce the memory corruption described in #27660.
// The bug was very timing sensitive; at the time of writing this
// test would only trigger the bug about once out of every five runs.

func test27660(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	ints := make([]int, 100)
	locks := make([]sync.Mutex, 100)
	// Slowly create threads so that ThreadSanitizer is forced to
	// frequently resize its SyncClocks.
	for i := 0; i < 100; i++ {
		go func() {
			for ctx.Err() == nil {
				// Sleep in C for long enough that it is likely that the runtime
				// will retake this goroutine's currently wired P.
				( /*line :2069:5*/_Cfunc_usleep /*line :2069:12*/)(1000 /* 1ms */)
				runtime.Gosched() // avoid starvation (see #28701)
			}
		}()
		go func() {
			// Trigger lots of synchronization and memory reads/writes to
			// increase the likelihood that the race described in #27660
			// results in corruption of ThreadSanitizer's internal state
			// and thus an assertion failure or segfault.
			i := 0
			for ctx.Err() == nil {
				j := rand.Intn(100)
				locks[j].Lock()
				ints[j]++
				locks[j].Unlock()
				// needed for gccgo, to avoid creation of an
				// unpreemptible "fast path" in this loop. Choice
				// of (1<<24) is somewhat arbitrary.
				if i%(1<<24) == 0 {
					runtime.Gosched()
				}
				i++

			}
		}()
		time.Sleep(time.Millisecond)
	}
}

// issue 28540

func twoargsF() {
	v := []string{}
	func() { _cgo0 := _Cfunc_twoargs2(); var _cgo1 _Ctype_int = func() _Ctype_int{ _cgoBase0 := /*line :2102:53*/&v; _cgo0 := /*line :2102:38*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); return _Cfunc_twoargs3(_cgo0); }(); _cgoCheckPointer(_cgo0, nil); _Cfunc_twoargs1(_cgo0, _cgo1); }()
}

// issue 28545

func issue28545G(p ** /*line :2107:22*/_Ctype_char /*line :2107:28*/) {
	func() { _cgo0 := /*line :2108:16*/p; var _cgo1 _Ctype_int = /*line :2108:19*/-1; var _cgo2 _Ctype_complexdouble = /*line :2108:23*/(0); _cgoCheckPointer(_cgo0, nil); _Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :2109:16*/p; var _cgo1 _Ctype_int = /*line :2109:19*/2 + 3; var _cgo2 _Ctype_complexdouble = /*line :2109:24*/complex(1, 1); _cgoCheckPointer(_cgo0, nil); _Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :2110:16*/p; var _cgo1 _Ctype_int = /*line :2110:19*/issue28772Constant; var _cgo2 _Ctype_complexdouble = /*line :2110:39*/issue28772Constant2; _cgoCheckPointer(_cgo0, nil); _Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
}

// issue 28772 part 1 - part 2 in testx.go

const issue28772Constant = ( /*line :2115:28*/_Ciconst_issue28772Constant /*line :2115:47*/)

// issue 28896

func offset(i int) uintptr {
	var pi  /*line :2120:9*/_Ctype_innerPacked /*line :2120:22*/
	var po  /*line :2121:9*/_Ctype_outerPacked /*line :2121:22*/
	var ui  /*line :2122:9*/_Ctype_innerUnpacked /*line :2122:24*/
	var uo  /*line :2123:9*/_Ctype_outerUnpacked /*line :2123:24*/
	switch i {
	case 0:
		return unsafe.Offsetof(pi.f2)
	case 1:
		return unsafe.Offsetof(po.g2)
	case 2:
		return unsafe.Offsetof(ui.f2)
	case 3:
		return unsafe.Offsetof(uo.g2)
	default:
		panic("can't happen")
	}
}

func test28896(t *testing.T) {
	for i := 0; i < 4; i++ {
		c := uintptr(( /*line :2140:16*/_Cfunc_offset /*line :2140:23*/)( /*line :2140:25*/_Ctype_int /*line :2140:30*/(i)))
		g := offset(i)
		if c != g {
			t.Errorf("%d: C: %d != Go %d", i, c, g)
		}
	}
}

// issue 29383
// cgo's /*line*/ comments failed when inserted after '/',
// because the result looked like a "//" comment.
// No runtime test; just make sure it compiles.

func Issue29383(n, size uint) int {
	if ^ /*line :2154:6*/_Ctype_size_t /*line :2154:14*/(0)/ /*line :2154:18*/_Ctype_size_t /*line :2154:26*/(n) <  /*line :2154:32*/_Ctype_size_t /*line :2154:40*/(size) {
		return 0
	}
	return 0
}

// issue 29748
// Error handling a struct initializer that requires pointer checking.
// Compilation test only, nothing to run.

var Vissue29748 = func() _Ctype_int{ _cgoBase0 := /*line :2164:28*/&_Ctype_S29748{	nil,}; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return _Cfunc_f29748(_cgo0); }()

func Fissue299748() {
	func() _Ctype_int{ _cgoBase0 := /*line :2169:11*/&_Ctype_S29748{	nil,}; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return _Cfunc_f29748(_cgo0); }()
}

// issue 29781

var issue29781X struct{ X int }

func issue29781F(...int) int { return 0 }

func issue29781G() {
	var p * /*line :2181:9*/_Ctype_char /*line :2181:15*/
	func() { _cgoBase0 := /*line :2182:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = _Ciconst_ISSUE29781C + 	1; _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_issue29781F(_cgo0, _cgo1); }()
	( /*line :2183:2*/_Cfunc_issue29781F /*line :2183:14*/)(nil, ( /*line :2183:22*/_Ctype_int /*line :2183:27*/)(
		0))
	func() { _cgoBase0 := /*line :2185:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2185:20*/(_Ctype_int)(0); _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_issue29781F(_cgo0, _cgo1); }()
	func() { _cgoBase0 := /*line :2186:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2186:20*/(_Ctype_int)(	0); _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_issue29781F(_cgo0, _cgo1); }()
	func() { _cgoBase0 := /*line :2188:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2188:20*/(_Ctype_int)(issue29781X. 	X); _cgoCheckPointer(_cgoBase0, 0 == 0); _Cfunc_issue29781F(_cgo0, _cgo1); }()
}

// issue 30065

func test30065(t *testing.T) {
	var a [256]byte
	b := []byte("a")
	func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :2197:26*/&a; _cgo0 := /*line :2197:11*/unsafe.Pointer(_cgoBase0); _cgoIndex1 := &/*line :2197:47*/b; _cgo1 := /*line :2197:31*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2197:54*/1; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return _Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if a[0] != 'a' {
		t.Errorf("&a failed: got %c, want %c", a[0], 'a')
	}

	b = []byte("b")
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2203:27*/a; _cgo0 := /*line :2203:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoIndex1 := &/*line :2203:50*/b; _cgo1 := /*line :2203:34*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2203:57*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return _Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if a[0] != 'b' {
		t.Errorf("&a[0] failed: got %c, want %c", a[0], 'b')
	}

	d := make([]byte, 256)
	b = []byte("c")
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2210:27*/d; _cgo0 := /*line :2210:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoIndex1 := &/*line :2210:50*/b; _cgo1 := /*line :2210:34*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2210:57*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return _Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if d[0] != 'c' {
		t.Errorf("&d[0] failed: got %c, want %c", d[0], 'c')
	}
}

// issue 31093
// No runtime test; just make sure it compiles.

func Issue31093() {
	( /*line :2220:2*/_Cfunc_issue31093F /*line :2220:14*/)( /*line :2220:16*/_Ctype_ushort /*line :2220:24*/(0))
}

// issue 32579

func test32579(t *testing.T) {
	var s [1] /*line :2226:11*/_Ctype_struct_S32579 /*line :2226:26*/
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2227:27*/s[0].data; _cgo0 := /*line :2227:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :2227:42*/1; var _cgo2 _Ctype_size_t = /*line :2227:45*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); return _Cfunc_memset(_cgo0, _cgo1, _cgo2); }()
	if s[0].data[0] != 1 {
		t.Errorf("&s[0].data[0] failed: got %d, want %d", s[0].data[0], 1)
	}
}

// issue 38649

var issue38649  /*line :2235:16*/_Ctype_netbsd_gid /*line :2235:28*/ = 42

// issue 39877

var issue39877 * /*line :2239:17*/_Ctype_void /*line :2239:23*/ = nil

// issue 40494
// No runtime test; just make sure it compiles.

func Issue40494() {
	( /*line :2245:2*/_Cfunc_issue40494 /*line :2245:13*/)( /*line :2245:15*/_Ctype_enum_Enum40494 /*line :2245:31*/(( /*line :2245:32*/_Ciconst_X_40494 /*line :2245:40*/)), (* /*line :2245:46*/_Ctype_union_Union40494 /*line :2245:64*/)(nil))
}
